      PROGRAM INTSFRACM_271
C     CSMITH 2016: COMPILE WITH THESE COMMANDS: gfortran -g -fno-automatic -fdefault-real-8 -fdefault-double-8 -o int6_271m int6_271m.f
C     gfortran -g -fno-automatic -fdefault-real-8 -fdefault-double-8 -o intsfracm_271 intsfracm_271.f agg_make_271.f miehiss_271.f
C     IN THIS VERSION WE FIX THE COMPUTATION OF CROSS SECTION (AND,
C       HENCE, OPTICAL DEPTH) FOR SCATTERING BY AGGREGATES AND THE
C       COMPUTATION OF M33 ACCORDING TO MARK LEMMON'S EMAIL OF
C       3/19/2005.
C     THIS VERSION ALLOWS A NEW INPUT VARIABLE, KABS, SPECIFYING
C     THE ABSORPTION COEFFICIENT FOR GAS 1 FOR ALL LAYERS -- 7/12/00
C     -- LRD
C     THIS IS THE WATCOM FORTRAN PC VERSION
C     DRIVER PROGRAM FOR PHOTOMETRY MODELS.  THIS VERSION ALLOWS UP
C     TO 20 LAYERS.  EACH LAYER MAY CONTAIN RAYLEIGH SCATTERING,
C     GASEOUS ABSORPTION, MIE SCATTERING, AND/OR HENYEY-GREENSTEIN
C     SCATTERING. (BOTH MIE AND HENYEY-GREENSTEIN IN ONE LAYER ARE
C     NOT ALLOWED)  INPUT PARAMETERS ARE CONTAINED IN THE NAMELIST
C     BELOW.  THIS PROGRAM IS BEING USED FOR TITAN MODELS
C     BEGINNING ABOUT 9/16/83.
C     MODIFIED TO INCLUDE UP TO 4 ABSORBING GASES - 10/85.
C     MODIFIED TO INCLUDE TABULAR PHASE FUNCTION - 11/27/85.
C     INTERFACE TO SHELLY'S CLOUD PHYSICS PROGRAM ADDED - 12/5/85
C     NUMLAYERS WAS INCREASED TO 30 - 7/2/91
C     ADDED HAPKE SURFACE PHASE FUNCTION - 4/9/97 - LRD
C     INCREASE TO UP TO 32 FOURIER COEFFICIENTS - 8/14/97 - LRD
C     REPLACE ORIGINAL HAPKE PARAMETERIZATION WITH THAT USED BY ARVIDSON
C       11/24/97 - LRD
C     REPLACE ARVIDSON VERSION OF HAPKE FUNCTION WITH THAT USED BY JOHNSON,
C     ET. AL. 2003
C     MODIFY DEFINITION OF JOHNSON DOUBLE HENYEY-GREENSTEIN TO CONFORM TO
C     JOHNSON'S NEW DEFINITION - 3/4/98 - LRD
C     ADD AGGREGATE PARTICLES AS A NEW TYPE OF AEROSOL - 3/1/00 - LRD
C     Compile on HP 9000/735 using
C       f77 -g +e -V +R -R8 +autodblpad -o intsfraca_271 intsfraca_271.f for debugging
C       f77 -O +e -K -R8 +autodblpad -o intsfraca_271 intsfraca_271.f for optimization
C
C     for Fortran 90 use:
C       f90 -g +r8 +save -o intsfraca_271 intsfraca_271.f agg_make_271.f miehiss_271.f for debugging
C       f90 -O +r8 +save -o intsfraca_271 intsfraca_271.f agg_make_271.f miehiss_271.f for optimization
C
C     for Portland Group compiler use:
C       f77 -g -r8 -Msave -Mlfs -o intsfracm_271 intsfracm_271.f agg_make_271.f miehiss_271.f for debugging
C       f77 -fast -r8 -Msave -Mlfs -o intsfracm_271 intsfracm_271.f agg_make_271.f miehiss_271.f for optimization
C     UNIT NUMBERS ARE ASSIGNED AS FOLLOWS:
C     UNIT 1       PLOTTER OUTPUT FILE (PHOTOM.PLT)
C     UNIT 2       DATA INPUT FILE.  THE PROGRAM WILL SELECT AMONG
C                  FILES BY WAVELENGTH AND PLANETARY REGION CODE.
C                  THE FILE EXTENSION IS THE WAVELENGTH AND THE THREE
C                  CHARACTERS BEFORE THE EXTENSION ARE THE REGION CODE.
C                  FOR EXAMPLE, MODELSEB.619 IS THE FILE NAME FOR DATA
C                  FROM THE SEB AT 0.619 MICRONS.
C
C     UNIT 3 IS THE OUTPUT FILE (EITHER THE PRINTER OR PHOTOM.PLT)
C     UNIT 5 IS THE CONSOLE (OR LOG FILE FOR BATCH JOBS).
C     UNIT 7 IS INPUT FILE FROM WHICH NAMELIST INPUT IS READ.
C
      PARAMETER (NUMCOEFS=256,NUMDPTS=160,NUMG=64,NUMLAYERS=32)

      logical od
      REAL LAT
      REAL NMIEP
      CHARACTER*8 PLANET
      DATA PLANET/'titan   '/
      DATA LAT/0./
      CHARACTER TITLE*132,FN*255,output*255,AGG_FN*255
      CHARACTER DATETIME*19
      CHARACTER*255 PHASETAB(NUMLAYERS),PHASETB,PHASENULL
      CHARACTER*255 SIZFN,BLANK,STRUCFN
      DATA BLANK/'                    '/
      REAL NMIE(NUMLAYERS),MRABSORB(4,NUMLAYERS),KABS(NUMLAYERS)
      INTEGER RAINLAYER
      DIMENSION WTAB(NUMLAYERS),TAUTAB(NUMLAYERS)
      DIMENSION FG(NUMLAYERS),WL(NUMLAYERS),TAU(NUMLAYERS),
     .WP(NUMLAYERS),DELTAP(NUMLAYERS),SPABND(NUMLAYERS),
     .MAXCO(NUMLAYERS),A(NUMLAYERS),B(NUMLAYERS),AMU1(NUMLAYERS),
     .AMU2(NUMLAYERS),F1(NUMLAYERS),G1(NUMLAYERS),G2(NUMLAYERS),
     .TAURAY(NUMLAYERS),TAUHG(NUMLAYERS),TAUMIE(NUMLAYERS),
     .TAUABS(4,NUMLAYERS),RSURFACE(NUMLAYERS),XLARGE(NUMLAYERS),
     .G(NUMLAYERS),WMIE(NUMLAYERS),REVDELP(NUMLAYERS),
     .LAYERDEF(2*NUMLAYERS),THETA_MIN(NUMLAYERS),TAUAGG(NUMLAYERS),
     .WAGG(NUMLAYERS),PAGGS(271),PAGG(271,NUMLAYERS)
      DIMENSION PD(271,NUMLAYERS),WMD(NUMLAYERS),SIGMAD(NUMLAYERS)
      DATA LAYERDEF/NUMLAYERS*0,NUMLAYERS*0/
      DATA CH4FAC/1.0/
      DIMENSION ABSCOEF(4)
      COMMON/COM/TITLE,P(271),MAXM,LFILE,NPRNT,WOTRU,FN,CALCI(NUMDPTS),
     .G1L,G2L,F1L,FGAS,A,B,WM,AMU1,AMU2,WAVL,SIGMA
      COMMON/IRR/RSURFACE,XLARGE,G,THETA_MIN
      COMMON/DA/IRECNO
      CHARACTER REGION*3
      COMMON/REG/REGION
      COMMON/CHI/CHISQ
      COMMON/SIZD/SIZFN,LAYER1(NUMLAYERS),LAYER2(NUMLAYERS)
      COMMON/LN/NLAYER

C
C     INPUT PARAMETERS ARE IN THE FOLLOWING NAMELIST:
C        WAVL IS THE WAVELENGTH IN MICROMETERS
C        DELTAP IS AN ARRAY OF PRESSURES DIFFERENCES (IN MB)
C        SPABND IS AN ARRAY OF SPECIFIC ABUNDANCES IN KM-AM OF N2 PER   This is actually the column abundances in km-atm
C             MEAN FREE PATH.
C        NMIE IS AN ARRAY OF PARTICLES ABUNDANCES (PER SQUARE CM) FOR
C             EACH LAYER FOR MIE PARTICLES.
C        F1,G1 AND G2 ARE THE USUAL HENYEY-GREENSTEIN PARAMETERS.
C        WP IS AN ARRAY OF SINGLE SCATTERING ALBEDOES FOR THE
C             PARTICLES IN EACH LAYER.
C        A, B, AMU1 AND AMU2 ARE THE USUAL MIE SCATTERING PARAMETERS
C             (EFFECTIVE SIZE, VARIANCE, REAL AND IMAGINARY INDICES)
C        MRABSORB IS THE ABSORBING GAS TO PRINCIPAL GAS MIXING RATIO
C        output IS TRUE FOR LINE PRINTER OUTPUT, FALSE TO DISPOSE OF
C             OUTPUT.
C        TITLE IS A COMMENT FIELD 132 CHARACTER LONG.
C
      NAMELIST/PFUNCS/PLANET,NCOEFS,WAVL,DELTAP,SPABND,NMIE,F1,G1,G2,
     .WP,A,B,AMU1,AMU2,WMIE,MRABSORB,output,TITLE,REGION,ABSCOEF,LAT,
     .TAURAY,TAUHG,TAUMIE,TAUABS,NMIEPTS,RSURFACE,XLARGE,G,THETA_MIN,
     .TAUTAB,WTAB,PHASETAB,SIZFN,STRUCFN,LAYERDEF,WAVLMIN,WAVLMAX,
     .GR,F0,CH,HAPKE_B0,HAPKE_B,HAPKE_C,HAPKE_H,AGG_FN,TAUAGG,
     .WAGG,RAINLAYER,KABS,NTES,IES

      NCOEFS=NUMCOEFS
      
      SIZFN=BLANK
      STRUCFN=BLANK
      output(1:10)='SINGLE.OUT'
	  PHASENULL=PHASETAB(1)
      
      DO I=1,NUMLAYERS
        THETA_MIN(I)=1.0E30
        KABS(I)=0.0D0
      ENDDO
C
C     OPEN INPUT FILE
C
27    OPEN(7,IOSTAT=IOS,FILE='namlist.int',STATUS='OLD')
      IF(IOS.NE.0) THEN
        WRITE(6,5001) IOS
5001    format(' ERROR ',I3,' OPENING namlist.int')
        PAUSE
        GO TO 27
      ENDIF

C      CALL RENEW('L:\TAPE10I.DAT')
      CALL RENEW('TAPE10I.DAT')
C      OPEN(10,FILE='L:\TAPE10I.DAT',STATUS='UNKNOWN',
C     & FORM='UNFORMATTED',RECL=NUMG*NUMG*32+16,ACCESS='DIRECT')
C      IRECNO=1
      OPEN(10,FILE='TAPE10I.DAT',STATUS='UNKNOWN',
     & FORM='UNFORMATTED',RECL=NUMG*NUMG*32+16,ACCESS='DIRECT')
      IRECNO=1
      
      open(13,file='tape10_rec_nos')
      
      OPEN(14,FILE='TAU&W.wpd')

      OPEN(3,FILE='SINGLE.OUT',STATUS='UNKNOWN')
C      IF(output.EQ.'YES         ') THEN
C        CALL RENEW('INTSCLD5.LOG')
C      ELSEIF(output(1:2).EQ.'NO') THEN
C        OPEN(3,FILE='/dev/null')
C      ELSE
C        CALL RENEW(output)
C        CLOSE(3)
C        OPEN(3,FILE=output,STATUS='NEW')
C      ENDIF
      
C     Change protection on S & T function file
C
C     COMPUTE A MODEL
C
10    ABSCOEF(1)=0.0
      ABSCOEF(2)=0.0
      ABSCOEF(3)=0.0
      ABSCOEF(4)=0.0
      WRITE(*,*) tauray
      READ(7,NML=PFUNCS,END=99)
      WRITE(*,*) tauray
      write(6,*) 'NAMLIST read OK'
      IF(NCOEFS.GT.NUMCOEFS) THEN
        NCOEFS=NUMCOEFS
        WRITE(6,5002) NCOEFS
5002    format(' NCOEFS set to ',I3,'by program.')
      ENDIF
      TITLE(109:130)=DATETIME(Q)

      LFILE=0
      NPRNT=0
      NBOT=0
      
C      PHASENULL=CHAR(0)//CHAR(0)//CHAR(0)//CHAR(0)//CHAR(0)//CHAR(0)
C     &        //CHAR(0)//CHAR(0)//CHAR(0)//CHAR(0)//CHAR(0)//CHAR(0)
C     &        //CHAR(0)//CHAR(0)//CHAR(0)//CHAR(0)//CHAR(0)//CHAR(0)
C     &        //CHAR(0)//CHAR(0)

      WRITE(3,FMT='(1X,A)') TITLE(1:130)
      WRITE(3,FMT='(1H0)')
      WRITE(3,NML=PFUNCS)
      WRITE(6,5003) WAVLMIN,WAVLMAX
5003  format(' BEGINNING WAVELENGTH INTERVAL ',F6.3,' TO ',F6.3)
      WRITE(3,5003) WAVLMIN,WAVLMAX
      WRITE(14,5003) WAVLMIN,WAVLMAX
C
      WRITE(6,5004)
5004  format('Layer       Rayleigh      Mie       Aggregate',
     & '       H-G     Tabular     Absorption      Layer')
      WRITE(14,5004)

C.....LOOP OVER 10 LAYERS TO SET PARAMETERS AND DO DOUBLINGS.
      DO 20 I=1,NUMLAYERS
      TAUR=0.0
      TAUMIES=0.0
      TAUHGS=0.0
      TAUABSB=0.0
      WMIES=0.0
      WM=0.0
      F1L=0.0
      G1L=0.0
      G2L=0.0
      DELP=0.0
      LAYER1(I)=LAYERDEF(2*I-1)
      LAYER2(I)=LAYERDEF(2*I)

C.....MIE SCATTERING?
      IF(NMIE(I).GT.0..OR.TAUMIE(I).GT.0..OR.
     &(SIZFN.NE.BLANK.AND.LAYER2(I).GE.LAYER1(I)
     &.AND.LAYER1(I).NE.0.AND.LAYER2(I).NE.0)) THEN
         CALL IRRSCAT(I,NMIEPTS)
C.....Changed this statement to include TAUMIE(I) - 2/14/92 - LRD
         IF(TAUMIE(I).EQ.0.0.AND.NMIE(I).EQ.0.0) THEN
           CALL CLOUDFIL(I,STRUCFN,DELP)
           NLAYER=I
           CALL CLOUDNUM(NMIEP)
         ELSE
           NMIEP=NMIE(I)
         ENDIF
         TAUMIES=SIGMA*NMIEP*1.0E-08
         IF(TAUMIE(I).GT.0.) TAUMIES=TAUMIE(I)
C.....CHOOSE EITHER THE ACTUAL SINGLE SCATTERING ALBEDO OR THE
C     ONE INPUT.
         IF(WMIE(I).EQ.0.) THEN
           WMIES=WM
         ELSE
           WMIES=WMIE(I)
         ENDIF
         WM=WMIES
      ENDIF
      
C.....AGGREGATE PARTICLES?
      IF(AGG_FN.NE.'!'.AND.I.LT.RAINLAYER) THEN
        CALL AGG2(I,WAVL,AMU1(I),AMU2(I),STRUCFN,TAUAGGS,WAGGS,PAGGS)
C.....IF THE USER HAS INPUT SPECIFIC VALUES FOR THE OPTICAL DEPTH
C     OR SINGLE SCATTERING ALBEDO, OVER RIDE THE COMPUTED VALUES
        IF(TAUAGG(I).NE.0.) TAUAGGS=TAUAGG(I)
        IF(WAGG(I).NE.0.) WAGGS=WAGG(I)
      ELSE
        TAUAGGS=0.0D0
        WAGGS=0.0D0
        DO J=1,271
          PAGGS(J)=0.0D0
        ENDDO
      ENDIF
      DO J=1,271
        PAGG(J,I)=PAGGS(J)
      ENDDO

C.....RAYLEIGH SCATTERING
C     Added to accommodate Mark Lemmon's "atmos.new" file on 12/21/99
C      IF(DELTAP(I).EQ.0..AND.STRUCFN.NE.BLANK.AND.
C     &LAYER1(I).NE.0.AND.LAYER2(I).NE.0) 
C     &CALL CLOUDML(I,STRUCFN,DELP)
      IF(DELTAP(I).EQ.0..AND.STRUCFN.NE.BLANK.AND.SPABND(I).NE.-1.0) 
     &CALL CLOUDML(I,STRUCFN,DELP)
C     End of addition on 12/21/99
      IF(DELTAP(I).EQ.0.) THEN
        REVDELP(I)=DELP
      ELSE
        REVDELP(I)=DELTAP(I)
      ENDIF
      TAUR=MAX(TAURAY(I),0.)
      IF(SPABND(I).NE.-1.0) 
     &CALL TAUMOL(PLANET,I,REVDELP,WAVL,MRABSORB(1,I),WMAINGAS,TAUR,
     & WN2,LAT)
      WR=1.0

C.....HENYEY-GREENSTEIN PARTICLES
      G1L=G1(I)
      G2L=G2(I)
      F1L=F1(I)
      IF(TAUHG(I).GT.0.) THEN
        TAUHGS=TAUHG(I)
        WHG=WP(I)
      ELSE
        IF(SPABND(I).LT.10000..AND.SPABND(I).GT.0.) THEN
          TAUHGS=WMAINGAS/SPABND(I)
          WHG=WP(I)
        ELSE
          TAUHGS=0.
          WHG=0.
        ENDIF
      ENDIF

C.....GASEOUS ABSORPTION
      DO 17 IGAS=1,4
      IF(TAUABS(IGAS,I).GT.0.) THEN
        TAUABSB=TAUABS(IGAS,I)*CH4FAC+TAUABSB
      ELSE IF(KABS(I).GT.0.) THEN
        IF(IGAS.EQ.1) TAUABSB=WMAINGAS*MRABSORB(1,I)*KABS(I)+TAUABSB
      ELSE
        TAUABSB=WMAINGAS*MRABSORB(IGAS,I)*ABSCOEF(IGAS)+TAUABSB
      ENDIF
17    CONTINUE
      WABS=0.0

C....."TABULAR" PARTICLES
      TAUTABS=TAUTAB(I)
      WTABS=WTAB(I)
      PHASETB=PHASETAB(I)

C     Check if all done with layers
      IF(TAUR+TAUHGS+TAUMIES+TAUABSB+TAUTABS+TAUAGGS.EQ.0.0.AND.
     &WP(I).EQ.0..AND.WTABS.EQ.0..AND.SPABND(I).NE.-1..AND.TAUHG(I)
     &.NE.-1.) GO TO 21
      NBOT=I

C.....COMPUTE GAS FRACTION, OPTICAL DEPTH, AND SINGLE SCATTERING
C     ALBEDO FOR THIS LAYER.
      IF(TAUR+TAUHGS+TAUMIES+TAUABSB+TAUTABS+TAUAGGS.NE.0.) THEN
        FG(I)=TAUR/(TAUR+TAUHGS*WHG+TAUMIES*WM+TAUTABS*WTABS+TAUAGGS*
     &    WAGGS)
        TAU(I)=TAUR+TAUHGS+TAUMIES+TAUABSB+TAUTABS+TAUAGGS
        WL(I)=(TAUR+TAUHGS*WHG+TAUMIES*WM+TAUTABS*WTABS+TAUAGGS*WAGGS)
     &    /TAU(I)
      ENDIF

C     Check for surface
      IF(SPABND(I).LT.0.0.OR.TAUHG(I).LT.0.0) THEN
C     Check for Lambert surface
        IF(PHASETAB(I).EQ.PHASENULL.AND.HAPKE_B0.EQ.0.0.AND.
C        IF(PHASETAB(1,I).EQ.PHASENULL(1).AND.HAPKE_B0.EQ.0.0.AND.
     &    HAPKE_B.EQ.0.0.AND.HAPKE_C.EQ.0.0.AND.HAPKE_H.EQ.0.0) THEN
          MAXM=1
          MAXCO(I)=1
          WRITE(6,5005) GR,WAVL
5005      format('GROUND IS A LAMBERT SURFACE OF REFLECTIVITY ',
     &      F5.3,' AT WAVELENGTH ',F6.4)
          WRITE(14,5005) GR,WAVL
        ELSE
C     Check for Hapke surface
          MAXM=NCOEFS
          MAXCO(I)=NCOEFS
          WRITE(6,5006) GR,HAPKE_B0,HAPKE_B,HAPKE_C,HAPKE_H,WAVL
5006      format(' GROUND IS A HAPKE SURFACE WITH W = ',
     &    F5.3,' B0 = ',1PG11.3,' B = ',1PG11.3,' C = ',
     &    1PG11.3,' AND H = ',1PG11.3,' AT WAVELENGTH ',0PF6.4)
          WRITE(14,5006) GR,HAPKE_B0,HAPKE_B,HAPKE_C,HAPKE_H,WAVL
        ENDIF
        WL(I)=WP(I)
        TAU(I)=-1.0
        NBOT=NBOT-1
        GO TO 21
      ELSEIF(TAUHGS+TAUMIES+TAUTABS+TAUAGGS.EQ.0.0) THEN
        MAXM=3
      ELSE
        MAXM=NCOEFS
      ENDIF

C.....WRITE LAYER PROPERTIES
      WRITE(6,5007) I,TAUR,TAUMIES,TAUAGGS,TAUHGS,TAUTABS,TAUABSB,
     &TAU(I),I,WR,WM,WAGGS,WHG,WTABS,WABS,WL(I)
5007  format(I3,2X,'TAU: ',1P6E12.4,4X,1PE12.4,/,I3,2X,'W  : ',
     &1P6E12.4,4X,1P4E12.4)
      WRITE(14,5007) I,TAUR,TAUMIES,TAUAGGS,TAUHGS,TAUTABS,TAUABSB,
     &TAU(I),I,WR,WM,WAGGS,WHG,WTABS,WABS,WL(I)
      WRITE(3,5008) I
5008  format('0',128('='),//,'  LAYER ',I2)
      WRITE(3,5009)
5009  format(/,'    TAU(R)    TAU(MIE)   TAU(AGG)   TAU(HG)',
     .'   TAU(TAB)   TAU(ABS)   W(MIE) W(AGG) W(HG)  W(TAB) FG',
     .'     WL     TAU')
      WRITE(3,5010) TAUR,TAUMIES,TAUAGGS,TAUHGS,TAUTABS,
     .TAUABSB,WM,WAGGS,WHG,WTABS,FG(I),WL(I),TAU(I)
5010  format(1X,1P6G11.3,0P7F7.3)

      MAXCO(I)=MAXM
      WOTRU=WL(I)
      FGAS=FG(I)
      CALL PHAZE(I,TAUR,TAUMIES,TAUAGGS,PAGGS,WAGGS,TAUHGS,WHG,TAUTABS,
     & WTABS,PHASETB)

      DO 15 J=1,271
15    PD(J,I)=P(J)
      WMD(I)=WM
      SIGMAD(I)=SIGMA
20    CONTINUE

21    MMAX=MAXCO(1)
      DO 25 I=2,NBOT
25    MMAX=MAX(MMAX,MAXCO(I))
      IF(TAU(NBOT+1).LE.0.0.OR.SPABND(NBOT+1).LE.0.0) THEN
        MMAX=MAX(MMAX,MAXCO(NBOT+1))
      ENDIF
      WRITE(10,REC=IRECNO) TITLE
      write(13,1100) IRECNO
1100  format(I6,'  TITLE')
      IRECNO=IRECNO+1
      WRITE(10,REC=IRECNO) HAPKE_B0,HAPKE_B,HAPKE_C,HAPKE_H
      write(13,1101) IRECNO
1101  format(I6,'  Hapke B0, B, C, and H')
      IRECNO=IRECNO+1
      IF(SPABND(NBOT+1).LT.0.0.OR.TAU(NBOT+1).LT.0.0) THEN
        WRITE(10,REC=IRECNO) WAVLMIN,WAVLMAX,GR,F0,NBOT+1,MMAX,
     &   (MAXCO(I),I=1,NBOT+1)
        write(13,1102) IRECNO
1102    format(I6,'  WAVLMIN, WAVLMAX, GR, F0, NBOT+1, MMAX, MAXCO')
        IRECNO=IRECNO+1
      ELSE
        WRITE(10,REC=IRECNO) WAVLMIN,WAVLMAX,GR,F0,NBOT,MMAX,
     &   (MAXCO(I),I=1,NBOT)
        write(13,1103) IRECNO
1103    format(I6,'  WAVLMIN, WAVLMAX, GR, F0, NBOT, MMAX, MAXCO')
        IRECNO=IRECNO+1
      ENDIF

      TAUA=0.0
      DO 30 I=1,NBOT
      TAUA=TAUA+TAU(I)
      DO 26 J=1,271
26    P(J)=PD(J,I)
      MAXM=MAXCO(I)
      WOTRU=WL(I)
      G1L=G1(I)
      G2L=G2(I)
      F1L=F1(I)
      FGAS=FG(I)
      WM=WMD(I)
      SIGMA=SIGMAD(I)
      IF(TAU(I).GT.0.) CALL DOUBLE(TAU(I),I)
30    CONTINUE

C     If there is a surface (Lambert or Hapke), add the functions for
C     that surface.
      IF(SPABND(NBOT+1).LT.0.0.OR.TAU(NBOT+1).LT.0.0) THEN
        NBOT=NBOT+1
        IF(PHASETAB(NBOT).EQ.PHASENULL.AND.HAPKE_B0.EQ.0.0.AND.HAPKE_B.
     &    EQ.0.0.AND.HAPKE_C.EQ.0.0.AND.HAPKE_H.EQ.0.0) THEN
C     We have a Lambert surface.
          CALL LAMBERT(GR,TAUA)
        ELSE
C     We have a Hapke surface.
          IF(TAU(NBOT).LE.0.0.OR.SPABND(NBOT).LE.0.0) THEN
            MAXM=MAX(MAXM,MAXCO(NBOT))
          ENDIF
          CALL HAPKE(GR,NBOT,TAUA,HAPKE_B0,HAPKE_B,HAPKE_C,HAPKE_H)
        ENDIF
      ENDIF
      
C     IF(output.NE.'NO          ') CLOSE(3)
      GO TO 10

   99 WRITE(10,REC=IRECNO) 'end of run'
      write(13,1104) IRECNO
1104  format(I6,'  end of run')
      CLOSE(10)
C     if (output .eq. 'NO') close(3,status='DELETE')
      close(13)
      close(3)
C     pause 'Normal Exit'
      STOP 'NORMAL EXIT'
      END
      SUBROUTINE PHAZE(ILAYER,TAUR,TAUMIES,TAUAGGS,PAGGS,WAGGS,TAUHGS,
     & WHG,TAUTAB,WTAB,PHASETAB)
      PARAMETER (NUMDPTS=160,NUMLAYERS=32)
      DIMENSION TTAB(361),PTAB(361)
      DIMENSION A(NUMLAYERS),B(NUMLAYERS),AMU1(NUMLAYERS),
     &AMU2(NUMLAYERS),PAGGS(271)
	  DIMENSION PS(271),PTABN(271)
      CHARACTER TITLE*132,FN*255,PHASETAB*255
      character alpha*80
      REAL LAMBDA
      DATA PI/3.14159265358979D0/
      COMMON/COM/TITLE,P(271),MAXM,LFILE,NPRNT,WOTRU,FN,CALCI(NUMDPTS),
     &G1,G2,F1,FGAS,A,B,WM,AMU1,AMU2,LAMBDA,EXTCRS
      COMMON/CAGG/PAGG(271)

C.....COMPUTE FRACTIONS OF EACH TYPE OF SCATTERING
      D=TAUR+TAUHGS*WHG+TAUMIES*WM+TAUTAB*WTAB+TAUAGGS*WAGGS
      FHG=TAUHGS*WHG/D
      FM=TAUMIES*WM/D
      FTAB=TAUTAB*WTAB/D
      FAGG=TAUAGGS*WAGGS/D

C.....output COMPOSITION OF PHASE FUNCTION TO UNIT 3
      WRITE(3,5011)
     & ILAYER,FGAS,FHG,F1,G1,G2,FM,A(ILAYER),B(ILAYER),AMU1(ILAYER),
     & AMU2(ILAYER),FTAB,PHASETAB,FAGG
5011  format(' Phase function for layer ',I2,'consists of:',/,
     &' Type                Weight    Parameters',/,
     &' Rayleigh           ',F8.3,2X,/,
     &' Henyey-Greenstein  ',F8.3,2X,'F1 = ',F5.3,'  G1 = ',F5.3,
     &'  G2 = ',F6.3,/,
     &' Mie                ',F8.3,2X,'A = ',F7.3,'  B = ',F8.5,
     &'  AMU1 = ',F6.4,'  AMU2 = ',G12.5,/,
     &' Tabular            ',F8.3,2X,'File = ',A,/,
     &' Aggregate = ',F8.3)

C.....PROCESS TABULAR PHASE FUNCTION, IF WE HAVE ONE
      IF(FTAB.GT.0.) THEN
        OPEN(8,FILE=PHASETAB,IOSTAT=IOS)
        IF(IOS.NE.0) THEN
         IF(IOS.EQ.908) THEN
           WRITE(6,5012) PHASETAB
5012       format('Could not open file ',A,'.')
           stop 'Phase function file missing'
         ELSE
           WRITE(6,5013) IOS,
     &       PHASETAB
5013       format(' Error ',I3,'opening file ',A)
           WRITE(6,5014)
5014       format(' Run aborted.')
           stop 'Run aborted'
         ENDIF
        ENDIF
 
        DO 50 I=1,361
          READ(8,*,END=60) TTAB(I),PTAB(I)
50      CONTINUE
        IF(TTAB(361).LT.179.999) THEN
          WRITE(6,5015) PHASETAB
5015      format(' Too many entries in file ',A,'.  Max is 361.',
     &    '  Run aborted.')
          stop 'Run aborted'
        ENDIF
60      NTAB=I-1
        CLOSE(8)

C.....NORMALIZE THE TABULAR PHASE FUNCTION BEFORE COMBINING IT WITH
C     OTHER COMPONENT PHASE FUNCTIONS (NEW CODE, 5/10/2014, LRD)
C.....GENERATE THE STANDARD GRID OF SCATTERING ANGLES AND INTERPOLATE
C     PTAB TO THE 271-POINT GRID
        RAD=PI/180.0D0
        DO 2 I=1,271
         THETA1=(MIN(I-1,100)*0.1 + MAX(I-101,0)*1.0)
         CALL LAGRN2(TTAB,PTAB,NTAB,THETA1,XTAB)
         PTABN(I)=XTAB
    2   PS(I)=XTAB*SIN(THETA1*RAD)
C     INTEGRAL FROM 0 TO 10 DEGREES WITH 0.1 DEGREE INTERVALS
        XINT = 0.0
        SUM = PS(1) + PS(101)
        FAC = 4.0
        DO 11 I=2,100
        SUM = SUM + FAC*PS(I)
        IF(ABS(FAC-4.0)-1.0E-6) 9,9,10
    9   FAC = 2.0
        GO TO 11
   10   FAC = 4.0
   11   CONTINUE
        XINT = (0.1*RAD*SUM)/3.0
C     INTEGRAL FROM 10 TO 180 DEGREES WITH 1.0 DEGREE INTERVALS
        SUM = PS(101) + PS(271)
        FAC = 4.0
        DO 14 I=102,270
          SUM = SUM + FAC*PS(I)
          IF(ABS(FAC-4.0)-1.0E-6) 12,12,13
   12     FAC = 2.0
          GO TO 14
   13     FAC = 4.0
   14   CONTINUE
        XINT = XINT + (1.0*RAD*SUM)/3.0
   15   XNORM = 0.5*XINT
        IF(NPRNT.NE.0) WRITE(3,103) XNORM
  103   FORMAT (//10X, 'NORMALIZATION INTEGRAL = ', F8.6)
        DO I=1,271
          PTABN(I)=PTABN(I)/XNORM
        ENDDO
      ENDIF

C.....ASSIGN PHASE FUNCTION AT EACH SCATTERING ANGLE, THETA
      WRITE(3,5016) ILAYER
5016  format(/,'Combined phase function for layer ',I2)
      WRITE(3,5017)
5017  format(' Scat Ang       P')
      DO 100 I=1,271
      THETAD=MIN(I-1,100)*0.1 + MAX(I-101,0)*1.0
      THETA=THETAD/57.29578
      X1=0.0D0
      X2=0.0D0
      XR=0.0D0
      XM=0.0D0
      XTAB=0.0D0
      XAGG=0.0D0

      IF(FHG.GT.0.) THEN
        CALL PHASE(F1,G1,THETA,X1)
        CALL PHASE(1.-F1,G2,THETA,X2)
      ENDIF

      IF(FGAS.GT.0.) THEN
        XR=0.75*(1.0+COS(THETA)**2)
      ENDIF

      IF(FM.GT.0.) THEN
        XM=P(I)
      ENDIF

C      IF(FTAB.GT.0.) THEN
C        CALL LAGRN2(TTAB,PTAB,NTAB,THETAD,XTAB)
C      ENDIF
      
      IF(FAGG.GT.0.) THEN
        XAGG=PAGGS(I)
      ENDIF

C      P(I)=FGAS*XR+FHG*X1+FHG*X2+FM*XM+FTAB*XTAB+FAGG*XAGG
      P(I)=FGAS*XR+FHG*X1+FHG*X2+FM*XM+FTAB*PTABN(I)+FAGG*XAGG
100   WRITE(3,'(1X,F8.2,2X,1PG13.6)') THETAD,P(I)

      RETURN
      END
      SUBROUTINE IRRSCAT(ILAYER,NMIEPTS)
      PARAMETER (NUMLAYERS=32,NUMDPTS=160)
      CHARACTER TITLE*132,FN*255
      REAL LAMBDA,KSCA,KABS,KEXT,P(271),KSTEXT
      DIMENSION AA(NUMLAYERS),BB(NUMLAYERS),AAMU1(NUMLAYERS),
     .AAMU2(NUMLAYERS)
      COMMON/COM/TITLE,CP(271),MAXM,LFILE,NPRNT,WOTRU,FN,
     .CALCI(NUMDPTS),G1,G2,F1,FGAS,AA,BB,WM,AAMU1,AAMU2,LAMBDA,
     .KSTEXT
      COMMON/IRR/RSURF(NUMLAYERS),XL(NUMLAYERS),GL(NUMLAYERS),
     .THETA_MINL(NUMLAYERS)
      COMMON/LN/NLAYER
      A=AA(ILAYER)
      B=BB(ILAYER)
      AMU1=AAMU1(ILAYER)
      AMU2=AAMU2(ILAYER)
      RSURFACE=RSURF(ILAYER)
      G=GL(ILAYER)
      XLARGE=XL(ILAYER)
      THETA_MIN=THETA_MINL(ILAYER)
      NLAYER=ILAYER

      IF(A.EQ.0.) THEN
C       Open the size distribution file
        CALL SIZFIL
        NLAYER=ILAYER

C       Get population of this layers
        CALL CLOUDNUM(XNR)

C       If no particles, return without doing Mie scattering
        IF(XNR.EQ.0.) THEN
          WM=0
          KSTEXT=0
          RETURN
        ENDIF
      ENDIF
      IF(RSURFACE.EQ.0.) THEN
        CALL MIESCAT(A,B,AMU1,AMU2,LAMBDA,NMIEPTS,P,KSCA,KABS,KEXT,
     &  W,ASYM)
      ELSE
        CALL IRRSCATR(A,B,AMU1,AMU2,LAMBDA,RSURFACE,G,XLARGE,THETA_MIN,
     &  NMIEPTS,P,KSCA,KABS,KEXT,W,ASYM)
      ENDIF
      DO 10 I=1,271
10    CP(I)=P(I)
      KSTEXT=KEXT
      WM=W
      END
      SUBROUTINE SIZFIL
C  Open the file containing size distribution data and determine the
C  number of size distribution bins.

      PARAMETER (NUMLAYERS=32)
      CHARACTER SIZFN*255,LINE*80,HEADER*80
      CHARACTER FIELD*3

C     Size distribution by layer array
      DIMENSION AN(39,50)

C     Pre-defined radii in Shelly's program
      DIMENSION RADIUS(41)

C     Size bin limits
      DIMENSION RADMIN(41),RADMAX(41)
      DIMENSION RAD(41),YP(41),TEMP(41),BIN(41)
      COMMON/SIZD/SIZFN,LAYER1(NUMLAYERS),LAYER2(NUMLAYERS)
      COMMON/LN/NLAYER
      DATA HEADER/'         1        2        3        4        5
     & 6        7        8     '/

      OPEN(8,FILE=SIZFN,STATUS='OLD')

   10 READ(8,5018,END=98) LINE
5018  format(A)
      ISTART=INDEX(LINE,'# OF LAYERS=')
      FIELD=LINE(ISTART+12:ISTART+14)

C     Read number of layers
      IF(ISTART.NE.0) THEN
        READ(FIELD,*) KBTM
      ELSE
        GO TO 10
      ENDIF

   20 READ(8,5020,END=99) LINE
5020  format(A)
      ISTART=INDEX(LINE,'# VOL BINS=')
      IF(ISTART.NE.0) THEN

C       Read number of layers
        FIELD=LINE(ISTART+11:ISTART+13)        
                READ(FIELD,*) NVOLBINS
      ELSE
        GO TO 20
      ENDIF

C  Read the size distribution for each of KBTM layers

   25 READ(8,5022) LINE
5022  format(A)
      ISTART=INDEX(LINE,HEADER)

C     Read one more blank line
      IF(ISTART.NE.0) THEN
        READ(8,5023)
5023    format(1X)
      ELSE
        GO TO 25
      ENDIF

      IF(NVOLBINS.GT.12) THEN
        NV=12
      ELSE
        NV=NVOLBINS
      ENDIF
      DO 111 K=1,KBTM
      READ(8,112) ZT,(AN(J,K),J=1,NV)
  112 FORMAT(1X,1F4.0,12E9.2)
  111 CONTINUE
C
      IF(NVOLBINS.GT.12) THEN
      READ(8,113)
  113 FORMAT(//)

      IF(NVOLBINS.GT.24) THEN
        NV=24
      ELSE
        NV=NVOLBINS
      ENDIF
      DO 114 K=1,KBTM
      READ(8,115) ZT,(AN(J,K),J=13,NV)
  115 FORMAT(1X,1F4.0,12E9.2)
  114 CONTINUE
      ENDIF
C
      IF(NVOLBINS.GT.24) THEN
      READ(8,116)
  116 FORMAT(//)

      NV=NVOLBINS
      DO 117 K=1,KBTM
      READ(8,118) ZT,(AN(J,K),J=25,NV)
  118 FORMAT(1X,1F4.0,12E9.2)
  117 CONTINUE
      ENDIF
C
C     Test to make sure everything in file has been read.
      READ(8,5024,END=26) LINE
5024  format(A3)

      if (LINE.NE.'end') THEN
        WRITE(6,5025) SIZFN,LINE
5025    format(' File ',A,' was not read completely.  Read ',
     &  /,1X,A,/,' when end was expected.  Run aborted.')
        stop 'File length wrong'
      end if
C
   26 CLOSE(8)

      CALL DEFRAD(NVOLBINS,RADIUS,RADMIN,RADMAX)
      RETURN

98    WRITE(6,5026) SIZFN
5026  format(' # OF LAYERS was not found in file ',A)
      stop 'Number of layers not found'
99    WRITE(6,5027) SIZFN
5027  format(' # VOL BINS was not found in file ',A)
      stop 'Number of volume bins not found'

      ENTRY SIZLIM(RMIN,RMAX)
C  Return RMIN and RMAX for this layer

      BINMAX=0.
      DO 40 I=1,NVOLBINS
      BIN(I)=0.
      DO 30 J=LAYER1(NLAYER),LAYER2(NLAYER)
   30 BIN(I)=BIN(I)+AN(I,J)
   40 BINMAX=MAX(BINMAX,BIN(I))
      MINBIN=NVOLBINS+1
      MAXBIN=0
      MINBINP=MINBIN
      MAXBINP=0
      DO 45 I=1,NVOLBINS
      IF(BIN(I)/BINMAX.GE.1.0E-04) THEN
        MINBIN=MIN(MINBIN,I)
        MAXBIN=MAX(MAXBIN,I)
      ENDIF
      IF(BIN(I).GT.0.) THEN
        MINBINP=MIN(MINBINP,I)
        MAXBINP=MAX(MAXBINP,I)
      ENDIF
   45 CONTINUE

      RMIN=RADMIN(MINBIN)
      RMAX=RADMAX(MAXBIN)

      RETURN

      ENTRY SIZLIMG(RMIN,RMAX,RMID)
C  Return RMIN, RMAX, and RMID for this layer

      BINMAX=0.
      DO 140 I=1,NVOLBINS
      BIN(I)=0.
      DO 130 J=LAYER1(NLAYER),LAYER2(NLAYER)
  130 BIN(I)=BIN(I)+AN(I,J)*(10.**RADIUS(I))**2
      BIN(I)=BIN(I)/(RADMAX(I)-RADMIN(I))
      IF(BIN(I).GT.BINMAX) THEN
        MIDBIN=I
        BINMAX=BIN(I)
      ENDIF
  140 CONTINUE
      IF(BINMAX.EQ.0.) THEN
        RMIN=0
        RMAX=0
        RMID=0
        RETURN
      ENDIF
      MINBIN=NVOLBINS+1
      MAXBIN=0
      MINBINP=MINBIN
      MAXBINP=0
      DO 145 I=1,NVOLBINS
      IF(BIN(I)/BINMAX.GE.1.0E-04) THEN
        MINBIN=MIN(MINBIN,I)
        MAXBIN=MAX(MAXBIN,I)
      ENDIF
      IF(BIN(I).GT.0.) THEN
        MINBINP=MIN(MINBINP,I)
        MAXBINP=MAX(MAXBINP,I)
      ENDIF
  145 CONTINUE

      RMIN=RADMIN(MINBIN)
      RMAX=RADMAX(MAXBIN)
      RMID=10.**RADIUS(MIDBIN)

C     WRITE(9,"(' LAYER ',I,'CONSISTING OF FINE LAYERS ',I,'THROUGH ',
C    &I,'.',/,' RMIN = ',G,' RMID = ',G,' RMAX = ',G)") NLAYER,
C    &LAYER1(NLAYER),LAYER2(NLAYER),RMIN,RMID,RMAX
      RETURN

      ENTRY SIZINIT
C  Average together the specified fine layers for this layer.

      DO 201 K=1,MAXBINP-MINBINP+1
      BIN(K)=0.
      NBIN=MINBINP+K-1
      DO 200 J=LAYER1(NLAYER),LAYER2(NLAYER)
200   BIN(K)=AN(NBIN,J)+BIN(K)
      RAD(K)=RADIUS(NBIN)

C     Number in bin per micron of radius
      BIN(K)=BIN(K)/(LAYER2(NLAYER)-LAYER1(NLAYER)+1)/(RADMAX(NBIN) -
     .RADMIN(NBIN))
201   CONTINUE
C201   WRITE(9,"(' BIN #',I2,' RADMIN = ',G12,' RADMID = ',G12,
C    &' RADMAX = ',G12,' POPULATION/MICRON = ',G12)") NBIN,
C    &RADMIN(NBIN),10.**RADIUS(NBIN),RADMAX(NBIN),BIN(K)
      CALL CURV1(MAXBINP-MINBINP+1,RAD,BIN,0.,0.,3,YP,TEMP,1.0,IERR)
      RETURN

      ENTRY SIZTAB(R,XNR)
      XNR=CURV2(LOG10(R),MAXBINP-MINBINP+1,RAD,BIN,YP,1.0)
C     WRITE(9,"(1X,G12,1X,G12)") R,XNR
      RETURN

      ENTRY CLOUDNUM(XNR)
C  Compute the total number of particles in a layer.

      XNR=0.
      DO 50 K=1,NVOLBINS
      DO 50 J=LAYER1(NLAYER),LAYER2(NLAYER)
   50 XNR=XNR+AN(K,J)

      RETURN
      END
      SUBROUTINE DOUBLE(TAUREQ,LAYER)
C
C     VERSION OF THE DOUBLING PROGRAM FOR NUMERICAL PHASE FUNCTIONS.
C     THIS VERSION TREATS SINGLE SCATTERING AND MULTIPLE SCATTERING
C     SEPARATELY FOR INCREASED EFFICIENCY (FEWER FOURIER COEFFICIENTS
C     ARE REQUIRED)
C     GENERATES INITIAL S AND T MATRICES FOR LAYER DOUBLING.
C     MONITORS DOUBLING PROCESS AND OUTPUTS DESIRED S AND T ARRAYS.
C
C     UNIT 3 IS THE OUTPUT
C
C     New version for INTSCLD, 1/27/91 - LRD

      PARAMETER (NUMCOEFS=256,NUMG=64,NUMDPTS=160,NUMLAYERS=32)
      DIMENSION FIJ(NUMG,NUMG)
      DIMENSION A(NUMLAYERS),B(NUMLAYERS),AMU1(NUMLAYERS),
     .AMU2(NUMLAYERS)
      DIMENSION SR2(NUMG,NUMG),TR2(NUMG,NUMG),SR1(NUMG,NUMG),TR1(NUMG,
     .NUMG)
      COMMON/SUN1/ WALB
      CHARACTER TITLE*132,FN*255
      REAL LAMBDA
      REAL SS(NUMG,NUMG),TS(NUMG,NUMG)
      COMMON/COM/TITLE,P(271),MAXM,LFILE,NPRNT,WOTRU,FN,CALCI(NUMDPTS),
     .G1,G2,F1,FGAS,A,B,WM,AMU1,AMU2,LAMBDA,EXTCRS
      COMMON/DB/NUM,M,MQUIT,TAU,TSTRT,TLAST,XMU(NUMG),W(NUMG),
     .S(NUMG,NUMG),T(NUMG,NUMG)
     .,PSM(NUMCOEFS,NUMG,NUMG),PTM(NUMCOEFS,NUMG,NUMG)
     .,SB(NUMCOEFS,NUMG,NUMG)
     .,SALL(NUMCOEFS),TALL(NUMCOEFS)
      COMMON/DA/IRECNO
C
C     Save the phase function for this layer on disk.  It will be used
C     by INTENSI3 for single scattering calculations.
      WRITE(10,REC=IRECNO) P
      write(13,1105) IRECNO
1105  format(I6,'  P')
      IRECNO=IRECNO+1

      NUM = NUMG
      CALL GAULEG(0.0,1.0,XMU,W,NUMG)
      
C
C     SET PARAMETERS AND INITIAL VALUES
C

      WRITE(3,5015)
 5015 FORMAT(1H0)

C
C     (XNORM OR THE 1-F OF HANSEN), USED TO SCALE TAU AND W(0).
C     IN THIS PROGRAM M IS THE ORDER OF THE FOURIER COEFFICIENT PLUS ONE
C     LFILE IS THE FILE NUMBER OF THE LAST FILE ALREADY ON THE TAPE.
C     NPRNT = 0 STOPS outputING OF S(M) AND T(M) VALUES IN OUTPUT SECTION
C     GENERATE THE (MAXM) FOURIER ORDERS OF THE PHASE FUNCTION.
C     FIRST, INITIALIZE SUBROUTINE PHASD   FOR SUBSEQUENT CALLS.
C
      NPRNT = 0
      CALL PHASD(F,G)

      XNORM = 1.- F
      WO = 1.0/(1.0 +(1.0-WOTRU)/(WOTRU*XNORM))
      WALB=WO
      FAC = XNORM*WOTRU/WO
      TAUDES = FAC*TAUREQ

C     Number of doubling required to reach tau = 1
      NDOUB21 = 10

C     Number less for higher order coefficients
      NLTM1 = 4
      NEXP = NDOUB21+LOG10(TAUDES)/LOG10(2.0)

      DO 4 I=1,NUM
      ZMU = XMU(I)
      DO 4 J=I,NUM
      ZMUO = XMU(J)

      CALL FOURIER(MAXM,ZMU,ZMUO,SALL,TALL)

      DO 3 N=1,MAXM
      PSM(N,I,J) = SALL(N)
      PSM(N,J,I) = SALL(N)
      PTM(N,I,J) = TALL(N)
      PTM(N,J,I) = TALL(N)
    3 CONTINUE
C
C     LOAD ZERO-ORDER PSM AND PTM FOR USE IN COMPUTING THE RENORMAL-
C     IZATION FACTORS OF THE PHASE FUNCTION.
C
      S(I,J) = SALL(1)
      S(J,I) = SALL(1)
      T(I,J) = TALL(1)
      T(J,I) = TALL(1)
    4 CONTINUE

      M = 1
C
C     GENERATE THE RENORMALIZATION FACTORS FOR THE TRANSMISSION FUNCTION
C
      CALL RENORMG(NUM,XMU,W,S,T,XNORM,FIJ,ITER)

      FIJMIN=3.402823D38
      FIJMAX=-3.402823D38
      DO 295 J=1,NUM
      DO 295 I=1,NUM
      FIJMIN=MIN(FIJ(I,J),FIJMIN)
  295 FIJMAX=MAX(FIJ(I,J),FIJMAX)

      WRITE(3,5028) FIJMIN,FIJMAX,ITER
5028  format(' THE RENORMALIZATION FACTORS LIE BETWEEN ',F9.6,
     .' AND ',F9.6,'.  ',I4,'ITERATIONS WERE REQUIRED.')

C     WRITE(3,994) ITER
C 994 FORMAT(///10X,'RENORMALIZATION FACTORS (AFTER',I3,
C    1' ITERATIONS)'//)
C
C     DO 995 I=1,NUM
C     WRITE(3,100) XMU(I),(FIJ(I,J), J=1,8)
  100 FORMAT(2X,F8.6,8(2X,E13.6))
C     WRITE(3,101) (FIJ(I,J), J=9,NUM)
  101 FORMAT(10X,3(2X,E13.6))
C 995 CONTINUE

C     WRITE(3,996) WOTRU,G
C 996 FORMAT(1H1,9X,'TAPE FILES FOR DOUBLING WITH W(0) = ',F6.4,
C    1' AND G = ',F6.4/)
C
C     BEGINNING OF THE LAYER DOUBLING FOR EACH FOURIER ORDER.
C
   50 MORD = M - 1

      DO 1 I=1,NUM
      DO 1 J=1,NUM
C
C     DIVIDE BY XNORM SO THAT THE NORMALIZATION INTEGRAL OF THE
C     TRUNCATED PHASE FUNCTION BECOMES UNITY (RATHER THAN XNORM).
C     RENORMALIZE TRANSMISSION FUNCTION, T.
C
      S(I,J) = PSM(M,I,J)/XNORM
      T(I,J) = (PTM(M,I,J)/XNORM)*FIJ(I,J)
C     COMPUTE THE SINGLE SCATTERING FUNCTIONS FOR EACH LAYER FOR THIS
C     COEFFICIENT
C
      TEMP=1./XMU(I)+1./XMU(J)
      SS(I,J)=S(I,J)/TEMP*(1.-EXP(-TAUREQ*TEMP))*WO
      IF(I.EQ.J) THEN
        TS(I,J)=TAUREQ*EXP(-TAUREQ/XMU(I))*T(I,J)*WO
      ELSE
        TS(I,J)=T(I,J)*XMU(I)*XMU(J)/(XMU(I)-XMU(J))*WO*
     &  (EXP(-TAUREQ/XMU(I))-EXXP(-TAUREQ/XMU(J)))
      ENDIF

1     CONTINUE
C
C     COMPUTE STARTING TAU FOR DOUBLING SO THAT FINAL OPTICAL
C     DEPTH WILL BE TAUDES.  FOR M = 1 START WITH A SMALLER
C     OPTICAL DEPTH THAN FOR OTHER FOURIER ORDERS.  THE MIN0
C     GUARDS AGAINST OPTICAL DEPTHS WHICH ARE SMALLER THAN REQUIRED
C     BEGINNING OPTICAL DEPTH.
C
      IF(M.EQ.1) THEN
        SFAC=1.
         IF(TAUDES.LT.999.0) THEN
            TAU=TAUDES*(2.0**(MIN0(-1,-NEXP)))
            TLAST=TAUDES/1.4
         ELSEIF(TAUDES.GE.999.0) THEN
            TAU=FAC*(2.0**(-25))
            TLAST=FAC/1.4*(2.0**15)
         ENDIF
      ELSEIF(M.GT.1) THEN
        SFAC=0.5
         IF(TAUDES.LT.16.0) THEN
            TAU=TAUDES*(2.0**MIN0(-1,NLTM1-NEXP))
            TLAST=TAUDES/1.4
         ELSEIF(TAUDES.GE.16.0) THEN
            TAU=FAC*(2.0**(-15))
            TLAST=FAC/1.4*16.0
         ENDIF
      ENDIF
      IF(M.LT.1) STOP 'ILLEGAL ORDER'
C
C     COMPUTE S(M) AND T(M) FOR SMALL STARTING TAU.
C     FOR ACCURACY MU AND MU(0) SHOULD BE 1.0E-3 OR LARGER.
C
      CALL FRSTORDR(SR1,TR1)
      CALL SCNDORDR(SR2,TR2)
      DO 40 J=1,NUM
      DO 40 I=1,NUM
      S(I,J)=SR1(I,J) + SFAC*SR2(I,J)
40    T(I,J)=TR1(I,J) + SFAC*TR2(I,J)

      TSTRT=TLAST

      NCALL = 0
      MQUIT = 0
C
C     WRITE HEADER FOR TAPE FILE CONTAINING ALL RESULTS FOR A GIVEN
C     FOURIER ORDER (M-1).
C
      NFILE = M + LFILE
      NREC = 1

C     Do another doubling
60    CONTINUE
      CALL DOUBL(NCALL)
C
C     OUTPUT S AND T FOR TAU VALUES BETWEEN TSTRT AND TLAST
C
      IF(NPRNT) 52,53,52
   52 TAUTRU = WO/(WOTRU*XNORM)*TAU
      WRITE(3,104) MORD,TAUTRU,WOTRU,G
  104 FORMAT(1H1,9X,'S(',I2,') FOR SCALED TAU =',E13.6,5X,
     1'W(0) = ',F6.4,5X,'G = ',F6.4//)

      DO 54 I=1,NUM
      WRITE(3,100) XMU(I),(S(I,J), J=1,8)
      WRITE(3,101) S(I,9)
   54 CONTINUE

      WRITE(3,105) MORD
  105 FORMAT(///10X,'T(',I2,')'//)

      DO 55 I=1,NUM
      WRITE(3,100) XMU(I),(T(I,J), J=1,8)
   55 WRITE(3,101) T(I,9)
   53 NREC = NREC + 1
      TAUTRU = WO/(WOTRU*XNORM)*TAU

C     Save functions for this Fourier order and layer on disk for
C     INTENSI3
      WRITE(10,REC=IRECNO) WOTRU,TAUREQ,S,T,SS,TS
      write(13,1106) IRECNO
1106  format(I6,'  WOTRU, TAUREQ, S, T, SS, TS')
      IRECNO=IRECNO+1

      IF(MQUIT) 57,60,57
C
C     DOUBLING FOR GIVEN M FINISHED, END OF FILE.
C
C     WRITE(3,571) NFILE,NREC
C 571 FORMAT(10X,'FILE',I4,' CONTAINS',I3,' RECORDS')
C     GO TO NEXT FOURIER ORDER DOUBLING IF DESIRED
57    IF(M .GE. MAXM) RETURN
      M = M + 1
      GO TO 50
      END
      SUBROUTINE TAUMOL(PLANET,I,DELTAP,WAVL,MRABSORB,WMAINGAS,TAUR,
     .LAT)
C  THIS SUBROUTINE IS PART OF THE PHOTOMETRY MODELING SYSTEM.
C  IT TAKES THE CURRENT LAYER, THE ARRAY OF PRESSURES, THE WAVELENGTH,
C  AND THE MIXING RATIO OF THE ABSORBING GAS AS INPUT.  IT RETURNS
C  THE ABUNDANCE OF THE MAIN GAS (IN KM-AM) AND THE RAYLEIGH SCATTERING
C  OPTICAL DEPTH FOR THIS LAYER.  IT CONTAINS TWO BASIC CONVERSIONS:
C  FROM PRESSURE TO ABUNDANCE (WHICH DEPENDS ON THE GRAVITY OF THE
C  PLANET), AND FROM ABUNDANCE TO OPTICAL DEPTH (WHICH DEPENDS ON
C  THE INDEX OF REFRACTION OF THE GAS AT THE CURRENT WAVELENGTH).
C

      PARAMETER (AN2=2.906E-04,BN2=7.7E-03,ACH4=4.335E-04,BCH4=6.E-03)
C  DEFINITION OF ABUNDANCE VS. PRESSURE RELATION FOR TITAN.  FORM USED
C  HERE IS W = P*10**AEXP
C
      REAL LAT,MTOT,JRADEQ,JRADPOL,JMASS,JNHENH2,JPER
      CHARACTER*(*) PLANET
      REAL MRABSORB
      DIMENSION PLOG(12),AEXP(12),DELTAP(*)
      DATA PLOG/-1.6530,-0.5,-0.11723,0.00218,0.49300,1.02018,1.48000,
     & 1.98205,2.46700,2.71609,2.95510,3.13816/
      DATA AEXP/-1.08000,-1.08000,-1.08270,-1.09859,-1.14901,-1.17601,
     & -1.19108,-1.20190,-1.20792,-1.20139,-1.20278,-1.20841/
      DATA GRAV,H2NUM,H2MASS /6.668E-8,2.69E24,3.32E-24/
      DATA SRADEQ,SRADPOL,SMASS /6.02E9,5.478E9,5.684E29/
      DATA SNHENH2,SPER /0.0638,36840./
      DATA JRADEQ,JRADPOL,JMASS /7.1398E9,6.677E9,1.901E30/
      DATA JNHENH2,JPER /0.1236,35729./
      TAUH2(B)=2.2682E-4/B**4+3.4113E-6/B**6+1.2827E-8/B**8
      TAUHE(B)=1.4985E-5/B**4+6.8516E-8/B**6+7.8793E-11/B**8
      TAURAYLY(X,Y,Z)=1.230E04*X**2*(1.0/Z**4+2.*Y/Z**6+Y**2/Z**8)
      IF(PLANET(1:5).EQ.'titan' .OR. PLANET(1:5).EQ.'TITAN') THEN
      IF(TAUR.EQ.0.) THEN
        IF(I.EQ.1) WMAINCUM=0.
C  COMPUTE THE PRESSURE TO THE BOTTOM OF THIS LAYER
        PRESS=0.
        DO 10 J=1,I
10      PRESS=PRESS+DELTAP(J)
C  GET VALUE OF PRESSURE COEFFICIENT TO COMPUTE ABUNDANCE
        CALL LAGRN2(PLOG,AEXP,12,LOG10(PRESS),AX)
C  COMPUTE THE TOTAL GAS ABUNDANCE IN KM-AM
        WMAINTOT=PRESS*10.**AX
        WMAINGAS=WMAINTOT-WMAINCUM
        WMAINCUM=WMAINTOT
        WN2=(1.0-MRABSORB)*WMAINGAS
	WCH4=MRABSORB*WMAINGAS
        TAUR=TAURAYLY(AN2,BN2,WAVL)*WN2+TAURAYLY(ACH4,BCH4,WAVL)*
     .    WCH4
      ELSE
        WN2=TAUR/(TAURAYLY(AN2,BN2,WAVL)+TAURAYLY(ACH4,BCH4,WAVL)*
     &    MRABSORB/(1.0-MRABSORB))
        WCH4=(WN2*MRABSORB)/(1.0-MRABSORB)
	WMAINGAS=WN2+WCH4
      ENDIF
      ELSEIF(PLANET(1:6).EQ.'SATURN') THEN
      IF(TAUR.EQ.0.) THEN
      ARG=LAT/57.2958
      RAD2=1./((COS(ARG)/SRADEQ)**2+(SIN(ARG)/SRADPOL)**2)
      RAD=SQRT(RAD2)
      G1=GRAV*SMASS/(RAD*RAD)
      G2=(2.*3.14159265358979/SPER)**2*RAD*COS(ARG)
      G=G1-G2
      MTOT=(1.+2.*SNHENH2)*H2NUM*H2MASS*1.E-3
      WMAINGAS=DELTAP(I)/(MTOT*G)
      TAUR=(TAUH2(WAVL)+TAUHE(WAVL)*SNHENH2)*WMAINGAS
      ELSE
      WMAINGAS=TAUR/(TAUH2(WAVL)+TAUHE(WAVL)*SNHENH2)
      ENDIF
      ELSEIF (PLANET(1:7) .EQ. 'JUPITER') THEN
      IF(TAUR.EQ.0.) THEN
      ARG=LAT/57.2958
      RAD2=1./((COS(ARG)/JRADEQ)**2+(SIN(ARG)/JRADPOL)**2)
      RAD=SQRT(RAD2)
      G1=GRAV*JMASS/(RAD*RAD)
      G2=(2.*3.14159265358979/JPER)**2*RAD*COS(ARG)
      G=G1-G2
      MTOT=(1.+2.*JNHENH2)*H2NUM*H2MASS*1.E-3
      WMAINGAS=DELTAP(I)/(MTOT*G)
      TAUR=(TAUH2(WAVL)+TAUHE(WAVL)*JNHENH2)*WMAINGAS
      ELSE
      WMAINGAS=TAUR/(TAUH2(WAVL)+TAUHE(WAVL)*JNHENH2)
      ENDIF
      ENDIF
      RETURN
      END
C      CHARACTER*18 FUNCTION DATETIME(Q)
      CHARACTER*19 FUNCTION DATETIME(Q)
C      CHARACTER*9 D
      CHARACTER*8 D
C      CHARACTER*8 T
      CHARACTER*10 T
C      CALL DATE(D)
C      CALL TIME(T)
      CALL DATE_AND_TIME(DATE=D,TIME=T)
      DATETIME=D//' '//T
      RETURN
      END
      SUBROUTINE PHASE(A,G,THETA,P)
      P = A*(1.0 - G*G)/((1.0 + G*G - 2.0*G*COS(THETA))**1.5)
      END
      SUBROUTINE FRSTORDR(SR1,TR1)
C  Compute the first order scattering from a layer with optical depth
C  TAU and single scattering albedo WO.
      PARAMETER (NUMG=64,NUMCOEFS=256)
      DOUBLE PRECISION BOT,TEMP1,DTAU,XMUJ,XMUI
      DIMENSION SR1(NUMG,NUMG),TR1(NUMG,NUMG)
      COMMON/SUN1/ WALB
      COMMON/DB/NUM,M,MQUIT,TAU,TSTRT,TLAST,XMU(NUMG),W(NUMG),
     .S(NUMG,NUMG),T(NUMG,NUMG)
     .,PSM(NUMCOEFS,NUMG,NUMG),PTM(NUMCOEFS,NUMG,NUMG)
     .,SB(NUMCOEFS,NUMG,NUMG)
     .,SALL(NUMCOEFS),TALL(NUMCOEFS)
      NUM=NUMG
C     DTAU=DBLE(TAU)
      DTAU=TAU

      DO 2 I=1,NUM
      XMUI=XMU(I)
      DO 2 J=1,NUM
      XMUJ=XMU(J)
      BOT = XMUI*XMUJ
      TEMP1=(XMUI+XMUJ)/BOT
C     CBS=WALB/TEMP1*(1.D0-DEXP(-DTAU*TEMP1))
      CBS=WALB/TEMP1*(1.0-EXP(-DTAU*TEMP1))
      IF(I.EQ.J) THEN
C     CBT=WALB*DTAU*DEXP(-DTAU/XMUJ)
      CBT=WALB*DTAU*EXP(-DTAU/XMUJ)
      ELSE
C     CBT=BOT/(XMUJ-XMUI)*WALB*(DEXP(-DTAU/XMUJ)-
C    .DEXP(-DTAU/XMUI))
      CBT=BOT/(XMUJ-XMUI)*WALB*(EXP(-DTAU/XMUJ)-
     .EXP(-DTAU/XMUI))
      ENDIF
      SR1(I,J)=CBS*S(I,J)
2     TR1(I,J)=CBT*T(I,J)
      END
      SUBROUTINE SCNDORDR(SR2,TR2)
C
C     Now compute the second order components of S and T using the
C     first order components just computed.  The method follows that
C     given by Hovenier, Astron. & Astrophys., Vol. 13, No. 1, 1971.
C     Note that his equations are in terms of R and T functions.  We
C     use S and T.  R = 4*mu*mu0*S and T(Hovenier) = 4*mu*mu0*T(Us).
C
C     The second order components are given by:
C     SR2(mu,mu0,M)=0.5 * Integral(0 to 1)(4*mu*mu'*T(mu,mu',M))*
C     (4*mu'*mu0*S(mu',mu0,M))*g(mu,mu0,mu')d(mu')  + 0.5 *
C     Integral(0 to 1)(4*mu*mu'*S(mu,mu',M))*(4*mu'*mu0*T(mu',mu0,M))*
C     h(mu,mu0,mu')d(mu')   and
C     TR2(mu,mu0,M)=0.5 * Integral(0 to 1)(4*mu*mu'*S(mu,mu',M))*
C     (4*mu'*mu0*S(mu',mu0,M))*e(mu,mu0,mu')d(mu')  +  0.5 *
C     Integral(0 to 1)(4*mu*mu'*T(mu,mu',M))*(4*mu'*mu0*T(mu',mu0,M))*
C     f(mu,mu0,mu')d(mu')
C
C     where e, f, g, and h are given by Hovenier.
C
      PARAMETER (NUMG=64,NUMCOEFS=256)
      DIMENSION DXP(NUMG)
      DIMENSION SR2(NUMG,NUMG),TR2(NUMG,NUMG)
      COMMON/SUN1/ WALB
      COMMON/DB/NUM,M,MQUIT,TAU,TSTRT,TLAST,XMU(NUMG),W(NUMG),
     .S(NUMG,NUMG),T(NUMG,NUMG)
     .,PSM(NUMCOEFS,NUMG,NUMG),PTM(NUMCOEFS,NUMG,NUMG)
     .,SB(NUMCOEFS,NUMG,NUMG)
     .,SALL(NUMCOEFS),TALL(NUMCOEFS)
      NUM=NUMG
      DTAU=TAU
C
C     Calculate all necessary exponentials in double precision
C
      DO 15 I=1,NUM
15    DXP(I)=EXP(-DTAU/XMU(I))
      DO 30 J=1,NUM
      XMUJ=XMU(J)
      DO 30 I=1,J
C     Take advantage of symmetry
      XMUI=XMU(I)
      SR2(I,J)=0.
      TR2(I,J)=0.
      DO 32 K=1,NUM
      XMUK=XMU(K)
C
C     Evaluate the Hovenier e function
C
      IF(I.NE.J) THEN
        EHOV=1.0/(4.0*(XMUJ+XMUK)) * (XMUJ/(XMUJ-XMUI)*
     .  (DXP(J)-DXP(I)) - XMUK/(XMUK+
     .  XMUI)*(DXP(J)-DXP(I)*DXP(J)*DXP(K)))
      ELSE
        EHOV=1.0/(4.0*(XMUJ+XMUK)) * (DTAU/XMUJ*DXP(J)
     .  -XMUK/(XMUK+XMUJ)*(DXP(J)-DXP(K)*DXP(J)**2))
      ENDIF
C
C     Evaluate the Hovenier f function
C
      IF(I.NE.J.AND.I.NE.K.AND.J.NE.K) THEN
        FHOV=1.0/(4.0*(XMUJ-XMUK)) * (XMUJ/(XMUJ-XMUI) *
     .  (DXP(J)-DXP(I)) - XMUK/(XMUK-
     .  XMUI)*(DXP(K)-DXP(I)))
      ELSE IF(I.EQ.J.AND.J.NE.K) THEN
        FHOV=1.0/(4.0*(XMUJ-XMUK)) * (DTAU/XMUJ*DXP(J)
     .  -XMUK/(XMUK-XMUJ) * (DXP(K)-DXP(J)))
      ELSE IF(J.NE.I.AND.I.EQ.K) THEN
        FHOV=1.0/(4.0*(XMUJ-XMUI)) * (XMUJ/(XMUJ-XMUI) *
     .  (DXP(J)-DXP(I)) - DTAU/XMUI*
     .  DXP(I))
      ELSE IF(I.NE.J.AND.J.EQ.K) THEN
        FHOV=1.0/(4.0*(XMUJ-XMUI)) * (DTAU/XMUJ*DXP(J)
     .  -XMUI/(XMUJ-XMUI) * (DXP(J)-DXP(I)))
      ELSE IF(I.EQ.J.AND.J.EQ.K) THEN
        FHOV=DTAU**2/(8.*XMUJ**3)*DXP(J)
      ENDIF
C
C     Evaluate the Hovenier g function
C
      IF(I.NE.K) THEN
        GHOV=1.0/(4.0*(XMUJ+XMUK)) * (XMUJ/(XMUJ+XMUI) *
     .  (1.-DXP(J)*DXP(I)) + XMUK/(XMUI-XMUK) *
     .  (DXP(K)*DXP(J)-DXP(I)*DXP(J)))
      ELSE
        GHOV=1.0/(4.0*(XMUJ+XMUI)) * (XMUJ/(XMUJ+XMUI) *
     .  (1.-DXP(J)*DXP(I))-DTAU/XMUI*DXP(J)*DXP(I))
      ENDIF
C
C     Evaluate the Hovenier h function
C
      IF(J.NE.K) THEN
        HHOV=1.0/(4.0*(XMUJ-XMUK)) * (XMUJ/(XMUJ+XMUI) *
     .  (1.-DXP(J)*DXP(I)) - XMUK/(XMUK+XMUI)
     .  *(1.-DXP(K)*DXP(I)))
      ELSE
        HHOV=1.0/(4.0*(XMUJ+XMUI)) * (XMUI/(XMUJ+XMUI) *
     .  (1.-DXP(J)*DXP(I)) - DTAU/XMUJ*
     .  DXP(J)*DXP(I))
      ENDIF
C
C     Proceed with the integration
C
      SR2(I,J)=SR2(I,J)+T(I,K)*S(K,J)*GHOV*W(K) +
     .                  S(I,K)*T(K,J)*HHOV*W(K)
32    TR2(I,J)=TR2(I,J)+S(I,K)*S(K,J)*EHOV*W(K) +
     .                  T(I,K)*T(K,J)*FHOV*W(K)
      SR2(I,J)=SR2(I,J)*2.*XMU(I)*XMU(J)*WALB**2
      TR2(I,J)=TR2(I,J)*2.*XMU(I)*XMU(J)*WALB**2
      IF(I.NE.J) THEN
        SR2(J,I)=SR2(I,J)
        TR2(J,I)=TR2(I,J)
      ENDIF
30    CONTINUE
      END
      SUBROUTINE DOUBL(NCALL)
C     IBM VERSION 3 ADAPTED TO CDC6400 USE
C     COMPUTES CHANDRASEKHAR SCATTERING AND TRANSMISSION FUNCTIONS,
C     S(M) AND T(M) FOR 2*TAU FOR FOURIER SERIES IN COS(M-1)(PHI-PHI(0))
C     USING THE LAYER-DOUBLING METHOD OF HANSEN, ASTROPHYSICAL JOURNAL,
C     VOLUME 155, PP. 565-573 (1969).
C     BY CONVENTION IN ALL ARRAYS Z(N,I,J) I SPECIFIES THE INCIDENCE
C     ANGLE MU(0), J SPECIFIES THE ANGLE OF OBSERVATION MU.
      PARAMETER (NUMCOEFS=256,NUMG=64,NUMDPTS=160,NUMLAYERS=32)
      COMMON/DB/NUM,M,MQUIT,TAU,TSTRT,TLAST,XMU(NUMG),W(NUMG),
     1S(NUMG,NUMG),T(NUMG,NUMG),SA(NUMCOEFS,NUMG,NUMG),
     .TA(NUMCOEFS,NUMG,NUMG),SB(NUMCOEFS,NUMG,NUMG)
     .,SALL(NUMCOEFS),TALL(NUMCOEFS)
      DIMENSION SIGO(NUMG,NUMG),SIGE(NUMG,NUMG),TEMP(7,NUMG,NUMG),
     .A(NUMG)
C     CALL STOPWACH(1,MSEC)
C     WRITE(6,"(' Entering DOUBL.  Time = ',I)") MSEC
      IF(NCALL) 50,60,50
   60 DO 1 I=1,NUM
    1 A(I) = W(I)/XMU(I)
       NCALL = 1
   50 IF(M-1) 11,10,11
   10 COEF = 0.5
      GO TO 12
   11 COEF = 0.25
12    CONTINUE
C     COMPUTATION OF TERMS OF S-SUMS SIGO AND SIGE (WHICH ARE SYMMETRIC).
      DO 13 I=1,NUM
      DO 13 J=1,NUM
   13 TEMP(1,I,J) = S(I,J)
      DO 15 NS=2,7
      DO 15 I=1,NUM
      DO 15 J=I,NUM
      SUMX = 0.0
      DO 14 K=1,NUM
   14 SUMX = SUMX + A(K)*TEMP(1,K,J)*TEMP(NS-1,I,K)
      TEMP(NS,I,J) = SUMX*COEF
   15 TEMP(NS,J,I) = TEMP(NS,I,J)
      DO 18 I=1,NUM
      DO 18 J=I,NUM
      IF(TEMP(6,I,J).EQ.0.) THEN
        R=0.
      ELSE
        R = TEMP(7,I,J)/TEMP(6,I,J)
      ENDIF
      RSQ = 1.0 - R*R
      IF(RSQ) 16,16,17
C     IF TEMP(7,I,J) IS SMALL, R MAY BE AFFECTED BY ROUNDOFF ERRORS.
   16 IF(ABS(TEMP(7,I,J)/TEMP(1,I,J))-1.0E-06) 161,161,162
  161 R = TEMP(5,I,J)/TEMP(4,I,J)
      IF(R.GT.1.0.OR.ABS(TEMP(5,I,J)/TEMP(4,I,J)).GT.1.0E-04) R=0.
      RSQ = 1.0 - R*R
      IF(RSQ) 162,162,163
  162 WRITE(3,99) I, J, TAU, (TEMP(NSS,I,J), NSS=1,7)
   99 FORMAT (/10X, I2, 2X, I2, 5X, E13.6/ 10X, 7E15.5//)
      WRITE(6,5029)
5029  format(' Program stopped by divergent series in DOUBL:')
      WRITE(6,5030) I, J, TAU, (TEMP(NSS,I,J), NSS=1,7)
5030  format(' I = ',I2,'  J = ',I2,'  TAU = ',G15.5,/,1X,5E15.5,/,
     .1X,2E15.5)
      STOP 16
  163 SIGO(I,J) = TEMP(1,I,J)+TEMP(3,I,J)+TEMP(5,I,J)/RSQ
      SIGE(I,J) = TEMP(2,I,J) + TEMP(4,I,J) + TEMP(5,I,J)*(R/RSQ)
      GO TO 164
   17 SIGO(I,J) = TEMP(1,I,J)+TEMP(3,I,J)+TEMP(5,I,J)+TEMP(7,I,J)/RSQ
      SIGE(I,J) = TEMP(2,I,J) + TEMP(4,I,J) + TEMP(6,I,J)
     1+ TEMP(7,I,J)*(R/RSQ)
  164 SIGO(J,I) = SIGO(I,J)
   18 SIGE(J,I) = SIGE(I,J)
C     COMPUTE THE FIVE SINGLE INTEGRALS REQUIRED FOR S AND T OF 2*TAU,
C     TAKING ADVANTAGE OF SYMMETRY RELATIONS.
      DO 21 I=1,NUM
      DO 21 J=I,NUM
      SUMX = 0.0
      SUMY = 0.0
      SUMA = 0.0
      SUMB = 0.0
      SUMC = 0.0
      DO 20 K=1,NUM
C     FIRST INTEGRAL FOR S
      SUMX = SUMX + A(K)*T(K,J)*SIGO(I,K)
C     SECOND INTEGRAL FOR S
      SUMY = SUMY + A(K)*SIGO(K,J)*T(I,K)
C     FIRST INTEGRAL FOR T
      SUMA = SUMA + A(K)*T(K,J)*T(I,K)
C     SECOND INTEGRAL FOR T
      SUMB = SUMB + A(K)*T(K,J)*SIGE(I,K)
C     THIRD INTEGRAL FOR T
   20 SUMC = SUMC + A(K)*SIGE(K,J)*T(I,K)
      TEMP(1,I,J) = SUMX*COEF
      TEMP(2,I,J) = SUMY*COEF
      TEMP(3,I,J) = SUMA*COEF
      TEMP(4,I,J) = SUMB*COEF
      TEMP(5,I,J) = SUMC*COEF
      TEMP(1,J,I) = TEMP(2,I,J)
   21 TEMP(4,J,I) = TEMP(5,I,J)
C     COMPUTE THE TWO DOUBLE INTEGRALS (WHICH ARE SYMMETRIC).
      DO 23 I=1,NUM
      DO 23 J=I,NUM
      SUMX = 0.0
      SUMY = 0.0
      DO 22 K=1,NUM
      SUMX = SUMX + A(K)*T(I,K)*TEMP(1,K,J)
   22 SUMY = SUMY + A(K)*T(I,K)*TEMP(4,K,J)
      TEMP(6,I,J) = SUMX*COEF
   23 TEMP(7,I,J) = SUMY*COEF
C     COMBINE INTEGRALS TO CONSTRUCT S AND T OF 2*TAU
      DO 24 I=1,NUM
      XO = EXP(-TAU/XMU(I))
      DO 24 J=I,NUM
      X = EXP(-TAU/XMU(J))
      S(I,J) = S(I,J) + X*XO*SIGO(I,J) + XO*TEMP(1,I,J) + X*TEMP(2,I,J)
     1+ TEMP(6,I,J)
      T(I,J) = (XO+X)*T(I,J) + X*XO*SIGE(I,J) + TEMP(3,I,J)
     1+XO*TEMP(4,I,J) + X*TEMP(5,I,J) + TEMP(7,I,J)
      S(J,I) = S(I,J)
   24 T(J,I) = T(I,J)
      TAU = 2.0*TAU
C     CALL STOPWACH(1,MSEC)
C     WRITE(6,"(' Doubled to TAU = ',1PG,' Time = ',I)") TAU,MSEC
      IF(TAU-TLAST) 26,25,25
   25 MQUIT = 1
      RETURN
   26 IF(TAU-TSTRT) 12,27,27
   27 RETURN
      END
      SUBROUTINE RENORMG(NUM, XMU, W, PS, PT, XNORM, FIJ, ITER)
C     RETURNS RENORMALIZATION FACTORS, FIJ, FOR USE WITH THE
C     TRANSMISSION FUNCTION. SEE HANSEN, J. ATMOS. SCI., 28, PP. 1400
C     TO 1426 (1971), APPENDIX B.
      PARAMETER (NUMCOEFS=256,NUMG=64,NUMDPTS=160,NUMLAYERS=32)
      DIMENSION XMU(NUMG), W(NUMG), PS(NUMG,NUMG), PT(NUMG,NUMG)
      DIMENSION R(NUMG), T(NUMG), FIJ(NUMG,NUMG), FIJP(NUMG,NUMG)
      DATA TOL,LIMIT/1.0E-6, 100/
C     INPUT ZERO-ORDER PHASE FUNCTION FOURIER COEFFICIENTS, PS(0) AND
C     PT(0), AND INITIALIZE FIJ FOR ITERATIVE CALCULATION.
C     DIVIDE BY XNORM SO THAT THE NORMALIZATION INTEGRAL OF THE
C     TRUNCATED PHASE FUNCTION BECOMES UNITY (RATHER THAN XNORM).
      DO 1 I=1,NUM
      DO 1 J=1,NUM
      PS(I,J) = PS(I,J)/XNORM
      PT(I,J) = PT(I,J)/XNORM
    1 FIJ(I,J) = 1.0
C     COMPUTATION OF R AND INITIAL T
      DO 200 J=1,NUM
      R(J) = 0.0
      T(J) = 0.0
      DO 2 I=1,NUM
      R(J) = R(J) + W(I)*PS(I,J)
    2 T(J) = T(J) + W(I)*PT(I,J)
      R(J) = 0.5*R(J)
  200 T(J) = 0.5*T(J)
      ITER = 0
C     TEST FOR CONVERGENCE
   50 DO 3 J=1,NUM
      EPSJ = ABS(1.0-R(J)-T(J))
      IF(EPSJ-TOL) 3,3,4
    3 CONTINUE
      RETURN
C     COMPUTE IMPROVED FIJ AND T
    4 ITER = ITER + 1
      DO 5 I=1,NUM
      DO 5 J=1,NUM
    5 FIJP(I,J) = FIJ(I,J)
      DO 6 J=1,NUM
      FACJ = 0.5*((1.0-R(J))/T(J))
      DO 6 I=1,NUM
      FACI = 0.5*((1.0-R(I))/T(I))
    6 FIJ(I,J) = FACJ*FIJP(I,J) + FACI*FIJP(J,I)
      DO 700 J=1,NUM
      T(J) = 0.0
      DO 7 I=1,NUM
    7 T(J) = T(J) + FIJ(I,J)*W(I)*PT(I,J)
  700 T(J) = 0.5*T(J)
      IF(ITER-LIMIT) 50,50,8
    8 WRITE(3,100) LIMIT
  100 FORMAT (/10X, 'RENORMALIZATION FAILS TO CONVERGE AFTER ', I3/)
      STOP 100
      END
      SUBROUTINE FOURIER(NUMC,XMU,XMUO,S,T)
C     Computes NUMC Fourier coefficients for the representation of the
C     PHI-PHI(0) dependence of PS and PT by direct integration.
      PARAMETER (NUMCOEFS=256,NUMG=64,NUMDPTS=160,NUMLAYERS=32)
      PARAMETER (NO=512)
      DIMENSION THETA(271), XCOS(0:NO,NUMCOEFS)
      COMMON /SUN2/ THETA,XCOS
      DIMENSION S(NUMCOEFS), T(NUMCOEFS)
      CHARACTER TITLE*132,FN*255
      COMMON/COM/TITLE,P(271),MAXM,LFILE,NPRNT,WOTRU,FN,CALCI(NUMDPTS),
     .G1,G2,F1,FGAS,XDUM1(NUMLAYERS),XDUM2(NUMLAYERS),XDUM3,
     .XDUM4(NUMLAYERS),XDUM5(NUMLAYERS),XDUM6,XDUM7
      DATA PI/3.14159265358979/

      RAD=PI/180.0
C     Maximum number of points used to do integral
      NEVAL=512
C     If Rayleigh, don't use so many points
      IF(NUMC.EQ.3) THEN
        IFAC=4
      ELSE
        IFAC=1
      ENDIF

      DO 10 M=1,NUMCOEFS
      S(M)=0.
10    T(M)=0.

C  Integrate over phi - phi0 using Simpson's rule with NEVAL intervals
C
      DPHI=PI/REAL(NEVAL)*IFAC
      MODTST=2*IFAC
      B=SQRT(1.-XMU**2)*SQRT(1.-XMUO**2)
      AT=XMU*XMUO
      AS=-AT
      DO 20 I=0,NEVAL,IFAC
C     Set the Simpson weight
      IF(MOD(I,MODTST).EQ.0) THEN
        WT=2.
      ELSE
        WT=4.
      ENDIF
      IF(I.EQ.0.OR.I.EQ.NEVAL) WT=1.
C
C  Compute the scattering angle
C
C     For reflection
      XS=AS+B*XCOS(I,1)
	IF(XS .GE. 1.0) THETAS=0.0
	IF(XS .LE. -1.) THETAS=PI
	IF(XS .LE. 1.0 .AND. XS .GE. -1.0) THEN
        THETAS=ACOS(AS+B*XCOS(I,1))
      ENDIF

C     For transmission
      XT=AT+B*XCOS(I,1)
	IF(XT .GE. 1.0) THETAT=0.0
	IF(XT .LE. -1.) THETAT=PI
	IF(XT .LE. 1.0 .AND. XT .GE. -1.0) THEN
        THETAT=ACOS(AT+B*XCOS(I,1))
      ENDIF
C
C  Interpolate for the phase function at these angles
C
      THETASD=THETAS/RAD
      THETATD=THETAT/RAD
C
C  The following two statements compute the number of the phase
C  function table entry which is just smaller than the scattering
C  angles.  They are valid for the new 271 point phase function
C  scheme used at this writing.  They must be changed if another
C  scheme is used.
C
      N1S=INT(MAX(0.,THETASD-10.)+MIN(THETASD,10.)/0.1)+1
      N1T=INT(MAX(0.,THETATD-10.)+MIN(THETATD,10.)/0.1)+1
C     Don't run off ends of table
      N1S=MIN(268,MAX(1,N1S-1))
      N1T=MIN(268,MAX(1,N1T-1))
      CALL LAGRN(THETA(N1S),P(N1S),THETAS,PS)
      CALL LAGRN(THETA(N1T),P(N1T),THETAT,PT)

C     Integrate the first coefficient
      S(1)=S(1)+PS*WT
      T(1)=T(1)+PT*WT
C     Integrate all other necessary coefficients
      DO 20 M=2,MAXM
      S(M)=S(M)+PS*XCOS(I,M-1)*WT
20    T(M)=T(M)+PT*XCOS(I,M-1)*WT

      DO 30 M=1,MAXM
      S(M)=S(M)*DPHI/3.*2./PI
30    T(M)=T(M)*DPHI/3.*2./PI
      S(1)=S(1)/2.
      T(1)=T(1)/2.
      RETURN
      END
      SUBROUTINE PHASD(SVAL,TVAL)
      PARAMETER (NUMCOEFS=256,NUMG=64,NUMDPTS=160,NUMLAYERS=32)
C  PHASD sets up two arrays for use in FOURIER.  THETA is the array
C  abcissae at which the phase function is originally defined.
C  XCOS is an array of cosines used in the Fourier coefficient
C  integrals
      PARAMETER (NO=512)
      LOGICAL DONEIT
      DIMENSION THETA(271), XCOS(0:NO,NUMCOEFS)
      COMMON /SUN2/ THETA,XCOS
      DIMENSION XDUM(43),PS(271)
      CHARACTER TITLE*132,FN*255
      COMMON/COM/TITLE,P(271),MAXM,LFILE,NPRNT,WOTRU,FN,
     .CALCI(NUMDPTS),G1,G2,F1,FGAS,XDUM1(NUMLAYERS),xdum2(NUMLAYERS),
     .xdum3,xdum4(NUMLAYERS),xdum5(NUMLAYERS),xdum6,xdum7
      DATA PI/3.14159265358979/
      DATA DONEIT/.FALSE./

      RAD=PI/180.0
      NEVAL=512
      IF(.NOT.DONEIT) THEN
      DONEIT=.TRUE.
      DTHET = 0.1*RAD
      DO 2 I=1,271
2     THETA(I)=(MIN(I-1,100)*0.1 + MAX(I-101,0)*1.0)*RAD
      DTHET=PI/REAL(NEVAL)
      DO 4 M=1,NUMCOEFS
      DO 4 I=0,NEVAL
4     XCOS(I,M)=COS(M*I*DTHET)
      ENDIF
      IF(NPRNT.NE.0) THEN
      WRITE(3,101)
  101 FORMAT (///, 9X, 'NORMALIZED PHASE FUNCTION, P(THETA)'//)
      FORPI = 4.0*PI
      DO 7 I=1,271
      X = THETA(I)/RAD
      P4PI = P(I)/FORPI
      IF(P(I)) 5,5,6
    5 PLOG = -100.0
      GO TO 7
    6 PLOG = LOG10(P(I))
    7 WRITE(3,102) I, X, P(I), PLOG, P4PI
  102 FORMAT (10X, I3, 3X, F6.2, 3(5X, F10.6))
      ENDIF
C     CALCULATION OF NORMALIZATION AND ASYMMETRY INTEGRALS
C     USING SIMPSONS RULE
      NCODE = 0
      DO 8 I=1,271
    8 PS(I) = P(I)*SIN(THETA(I))
C     INTEGRAL FROM 0 TO 10 DEGREES WITH 0.1 DEGREE INTERVALS
   20 XINT = 0.0
      SUM = PS(1) + PS(101)
      FAC = 4.0
      DO 11 I=2,100
      SUM = SUM + FAC*PS(I)
      IF(ABS(FAC-4.0)-1.0E-6) 9,9,10
    9 FAC = 2.0
      GO TO 11
   10 FAC = 4.0
   11 CONTINUE
      XINT = (0.1*RAD*SUM)/3.0
C     INTEGRAL FROM 10 TO 180 DEGREES WITH 1.0 DEGREE INTERVALS
      SUM = PS(101) + PS(271)
      FAC = 4.0
      DO 14 I=102,270
      SUM = SUM + FAC*PS(I)
      IF(ABS(FAC-4.0)-1.0E-6) 12,12,13
   12 FAC = 2.0
      GO TO 14
   13 FAC = 4.0
   14 CONTINUE
      XINT = XINT + (1.0*RAD*SUM)/3.0
      IF(NCODE) 17,15,17
   15 XNORM = 0.5*XINT
      F = 1.0 - XNORM
      IF(NPRNT.NE.0) WRITE(3,103) XNORM, F
  103 FORMAT (//10X, 'NORMALIZATION INTEGRAL = ', F8.6// 10X,
     1'HANSENS SCATTER FRACTION, F = ', F8.6//)
      NCODE = 1
      DO 16 I=1,271
   16 PS(I) = PS(I)*COS(THETA(I))
      GO TO 20
   17 G = 0.5*XINT
      IF(NPRNT.NE.0) WRITE(3,104) G
  104 FORMAT (10X, 'ASYMMETRY INTEGRAL, G = ', F8.6//)
      SVAL = F
      TVAL = G
      RETURN
      END
        FUNCTION EXXP(POWER)
        EXXP=0.
        IF(POWER.GT.-179.) EXXP=EXP(POWER)
        RETURN
        END
      SUBROUTINE FOFIND(NPT,OBSI,SIGMAS,FO,FOMIN,FOMAX)

      PARAMETER (NUMCOEFS=256,NUMDPTS=160,NUMG=64,NUMLAYERS=32)
C
C      FINDS THE VALUE OF THE CONSTANT FO WHICH YIELDS THE BEST FIT OF
C      THE MODEL POINTS TO THE OBSERVATION POINTS OF ALL IMAGES USED.
C

      DIMENSION OBSI(NUMDPTS),SIGMAS(NUMDPTS)
      CHARACTER TITL*132,FN*255
      REAL LAMBDA
      DIMENSION A(NUMLAYERS),B(NUMLAYERS),AMU1(NUMLAYERS),
     .AMU2(NUMLAYERS)
      COMMON/COM/TITL,P(271),MAXMM,LFILE,NPRNT,WOTRU,FN,CALCI(NUMDPTS)
     .,G1,G2,F1,FGAS,A,B,WM,AMU1,AMU2,LAMBDA,EXTCRS
      SUMT = 0.0
      SUMW = 0.0

      DO 10 I=1,NPT
      WT=(CALCI(I)/SIGMAS(I))**2
      FO=OBSI(I)/CALCI(I)
      SUMW=SUMW+WT
      SUMT=SUMT+FO*WT
   10 CONTINUE

      FO = SUMT/SUMW
      IF(FO.LT.FOMIN) FO=FOMIN
      IF(FO.GT.FOMAX) FO=FOMAX
      RETURN
      END
      SUBROUTINE LAGRN(XT,FXT,X,FX)

C
C      FOUR POINT LAGRANGIAN INTERPOLATION TO OBTAIN FX GIVEN X AND FXT,
C      THE ORDINATES FOR NONEQUALLY SPACED TABULAR ABCISSAS, XT.
C

      DIMENSION XT(4),FXT(4),P(4)

      DO 1 I=1,4
      IF(X .EQ. XT(I)) GO TO 2
    1 CONTINUE
      GO TO 3

    2 FX = FXT(I)
      RETURN

C
C      COMPUTE DENOMINATORS OF LAGRAGIAN COEFFIEIENTS
C

    3 DO 5 I=1,4
      PROD = 1.0
      DO 4 J=1,4
      IF(I .EQ. J) GO TO 4
      PROD = PROD*(XT(I) - XT(J))
    4 CONTINUE
      P(I) = PROD
    5 CONTINUE

C
C      COMPUTE GENERAL NUMERATOR
C

      PROD = 1.0
      DO 6 I=1,4
      PROD = PROD*(X - XT(I))
    6 CONTINUE

C
C      COMPUTE LAGRANGIAN COEFFICIENTS AND THE INTERPOLATED VALUE
C

      FX = 0.0
      DO 7 I=1,4
      XL = PROD/(P(I)*(X - XT(I)))
      FX = FX + XL*FXT(I)
    7 CONTINUE
      RETURN
      END
      SUBROUTINE ADDUP(TAUA,SA,TA,SB,M)
      PARAMETER (NUMCOEFS=256,NUMDPTS=160,NUMG=64,NUMLAYERS=32)
      COMMON/ADDL/XMU,HWTOMU,QWTOMU,N,NMAX,SCRIT
      DIMENSION SA(NUMG,NUMG),TA(NUMG,NUMG),SB(NUMG,NUMG)
      DIMENSION SLAST(NUMG,NUMG)
      DIMENSION SIGO(NUMG,NUMG)
      DIMENSION PT5(NUMG,NUMG)
      DIMENSION ETAUA(NUMG)
      DIMENSION SBSA(NUMG,NUMG)
      DIMENSION SN(NUMG,NUMG)
      DIMENSION TAWT(NUMG,NUMG)
      DIMENSION XMU(NUMG),HWTOMU(NUMG),QWTOMU(NUMG),WTOMU(NUMG)
C      EQUIVALENCE (PT5(1),SN(1)),(TAWT(1),SLAST(1))

      IN = N/2

      IF(M .NE. 1) GO TO 15
      DO 10 I=1,N
   10 WTOMU(I) = HWTOMU(I)
      GO TO 25
   15 DO 20 I=1,N
   20 WTOMU(I) = QWTOMU(I)

   25 DO 30 I=1,N
      TEMP = TAUA/XMU(I)
      ETAUA(I) = 0.0
   30 IF(TEMP .LE. 100.0) ETAUA(I) = EXP(-TEMP)

C
C     COMPUTE SBSA INTEGRAL, INITIALIZE SN, SIGO,Q1,Q2, NT
C

      DO 40 I=1,N
      DO 40 J=1,N
      SBSA(I,J) = 0.0
      DO 35 K=1,N
   35 SBSA(I,J) = SBSA(I,J) + SB(I,K)*SA(K,J)*WTOMU(K)
      SN(I,J) = SB(I,J)
   40 SIGO(I,J) = 0.0

      Q1 = 0.0
      Q2 = 0.0
      NT = 1

C
C     COMPUTE SN(NT) WITH NT ODD
C

   45 NT = NT + 2
      NGG = 1
      DO 50 I=1,N
      DO 50 J=I,N
      SIGO(I,J) = SIGO(I,J) + SN(I,J)
      SLAST(I,J) = SN(I,J)
   50 SLAST(J,I) = SLAST(I,J)
      DO 60 I=1,N
      DO 60 J=I,N
      SN(I,J) = 0.0
      DO 55 K=1,N
   55 SN(I,J) = SN(I,J) + SBSA(I,K)*SLAST(K,J)*WTOMU(K)
   60 IF(SN(I,J) .GT. SIGO(I,J) * 1.0E-06) NGG = 0

C
C     TEST IF TIME TO STOP EVALUATING TERMS
C

      D1 = Q1
      D2 = Q2
      Q1 = SN(IN,N)/SLAST(IN,N)
      Q2 = SN(N,N)/SLAST(N,N)
      IF(NGG .EQ. 1) GO TO 100
      IF(NT .LT. 5) GO TO 45
      AM = (Q1/D1 + Q2/D2)*0.5 - 1.0
      IF(AM .LT. 0.0) AM = -AM
      IF(NT .GE. NMAX) GO TO 100
      IF(AM .GT. SCRIT) GO TO 45

C
C     APPROXIMATE REST OF SIGO BY GEOMETRIC SERIES.
C

  100 DO 130 I=1,N
      DO 130 J=I,N
      IF(SLAST(I,J).EQ.0.) GO TO 115
      BOT = 1.0 - SN(I,J)/SLAST(I,J)
      IF(BOT.GT.0.0) GO TO 120
      WRITE(6,110) NT,I,J,SIGO(I,J),SLAST(I,J),SN(I,J),BOT
  110 FORMAT(2X,3I5,1P4E16.8)
  115 BOT = 1.0
  120 SIGO(I,J) = SIGO(I,J) + SN(I,J)/BOT
  130 SIGO(J,I) = SIGO(I,J)

C
C     EVALUATE S(I,J) FOR COMPOSITE LAYERS FOR ILLUMINATION
C     FROM ABOVE.
C

      DO 305 I=1,N
      DO 305 J=1,N
  305 TAWT(I,J) = TA(I,J)*WTOMU(I)
      DO 310 I=1,N
      DO 310 J=1,N
      PT5(I,J) = 0.0
      DO 310 K=1,N
  310 PT5(I,J) = PT5(I,J) + SIGO(I,K)*TAWT(K,J)
      DO 320 I=1,N
      DO 320 J=1,N
      T5 = 0.0
      DO 315 K=1,N
  315 T5 = T5 + TAWT(K,I)*PT5(K,J)
      T4 = PT5(I,J)*ETAUA(I)
      T3 = PT5(J,I)*ETAUA(J)
      T2 = ETAUA(I)*SIGO(I,J)*ETAUA(J)
      SB(I,J) = SA(I,J) + T2 + T3 + T4 + T5
  320 SB(J,I) = SB(I,J)
      RETURN
      END
      SUBROUTINE DISPLA(N,STRING,VALUE)
      CHARACTER STRING*100
      WRITE(6,5031) STRING(1:N),VALUE
5031  format(1X,A,1PG13.6)
      RETURN
      END
      SUBROUTINE EDIT(TAUL,WL,NBOT,MAXCO)
      PARAMETER (NUMCOEFS=256,NUMDPTS=160,NUMG=64,NUMLAYERS=32)
      CHARACTER FN*255,F2N*255,TITLE*132
      CHARACTER REGION*3,NLAMBDA*3
      DIMENSION TAUL(NUMLAYERS),WL(NUMLAYERS),MAXCO(NUMLAYERS)
      DIMENSION A(NUMLAYERS),B(NUMLAYERS),AMU1(NUMLAYERS),
     .AMU2(NUMLAYERS)
      REAL LAMBDA
      COMMON/COM/TITLE,P(271),MAXM,LFILE,NPRNT,WOTRU,FN,CALCI(NUMDPTS),
     .G1,G2,F1,FGAS,A,B,WM,AMU1,AMU2,LAMBDA,EXTCRS
      COMMON/REG/REGION

      ILAMBDA=LAMBDA*10**(3-INT(LOG10(LAMBDA)+1))
      WRITE(NLAMBDA,5032) ILAMBDA
5032  format(I3)
      F2N='MODEL'//REGION//'.'//NLAMBDA

110   OPEN(2,IOSTAT=IOS,FILE=F2N,STATUS='OLD')
      IF(IOS.NE.0) THEN
      WRITE(6,5033) IOS,F2N
5033  format(' ERROR ',I3,' OPENING FILE ',A)
      PAUSE
      GO TO 110
      ENDIF

      REWIND 2

      WRITE(2,5034) TITLE(1:130)
5034  format(1H',A,1H')
      REWIND 2
      READ(2,5035) TITLE(1:130)
5035  format(1X,A)
      READ(2,*) NPTS

C.....SKIP TO END STRUCTURE DEFINITION PART OF MODEL FILE.
      DO 200 I=1,NPTS
200   READ(2,5036)
5036  format(1X)
C.....DEFINE NEW STRUCTURE
      DO 400 I=1,NBOT
400   WRITE(2,5037) WL(I),TAUL(I),MAXCO(I)
5037  format(1PG13.6,1X,1PG13.6,I5)
      ENDFILE 2
      REWIND 2
      RETURN
      END
      SUBROUTINE ADM5(REV,HALFON,HALFOFF)
      CHARACTER REV*2,HALFON*2,HALFOFF*2
      REV(1:1)=CHAR(27)
      REV(2:2)=CHAR(71)
      HALFON(1:1)=CHAR(27)
      HALFON(2:2)=CHAR(41)
      HALFOFF(1:1)=CHAR(27)
      HALFOFF(2:2)=CHAR(40)
      RETURN
      END
      FUNCTION TAUCUML(FG,TAUP0,TAUG0,X)
      TAUCUM=(LOG10(1.-FG)-LOG10(X*FG)-LOG10(TAUP0)
     .+X*LOG10(TAUG0))/(X-1.) + LOG10(FG*(X-1.)+1.)
     .-LOG10(X*FG)
      TAUCUML=10.**TAUCUM
      RETURN
      END
      SUBROUTINE IRRSCATR(A,B,AMU1,AMU2,LAMBDA,RSURFACE,G,XLARGE,
     .THETA_MIN,NMIEPTS,CP,KSTSCA,KSTABS,KSTEXT,WM,GTEMP)
C
C  This subroutine computes scattering parameters for either spherical
C  of irregular particles by the method described by Pollack and
C  Cuzzi, Journal of the Atmospheric Sciences 37, 868-881 (1980).
C  This version contains the update to theory proposed by Showalter
C  which permit the phase function to have a minimum and increase again
C  at larger scattering angles.
C  For spherical particles this subroutine must be supplied with
C       A      the cross-sectionally weighted average particle radius
C       B      the size distribution dispersion (Hansen-type size
C              distribution)
C       AMU1   the real part of the index of refraction
C       AMU2   the imaginary part of the index of refraction
C       LAMBDA the wavelenth (in the same units as A)
C
C  For irregular particles this subroutine also needs
C       RSURFACE  the ratio of the surface area of the irregular
C                 particle to that of an equal volume sphere
C       XLARGE    a boundary of the size parameter below which the
C                 the particle scattering is well represented by
C                 Mie scattering
C       G         an empirical constant dependent upon the slope of
C                 the transmitted light component of the phase
C                 function
C       THETA_MIN the scattering angle of the phase function minimum
C
C  Some typical values given by Pollack and Cuzzi are
C
C                  RSURFACE          XLARGE             G
C  Cubes            1.3                4               1.5
C  Octahedrons      1.1                8               2.0
C  Convex-concave   1.3               10               4.0
C  Plates or flakes 1.3                3               5.0
C
C  The program keys on RSURFACE.  If it is 0 the particles are assumed
C  to be spherical.  The size distribution is assumed to be given by
C  FUNCTION SIZDIS(R), where R is the particle "radius".
C
      DIMENSION P(271)
      DIMENSION THETA(271)
      DIMENSION SS(271)
      DIMENSION SUMSS(271),SUMDX(271)
      DIMENSION SIGSCA(271),CP(271)
      REAL ID(271),IR(271),IT(271)
      REAL IDTEMP
      REAL LAMBDA
      REAL K,KSCA,KABS
C     REAL KSSCA,KSABS,KSEXT
      REAL KSTSCA,KSTABS,KSTEXT
      REAL LXSUM,LNSUM

      NPRNT=2
      PI = 3.14159265358979
      RADIANS = PI/180.0
      TWOPI = 2.0*PI

      XINT = 0.0

      K = TWOPI/LAMBDA

      DO 5 I=1,271
      SIGSCA(I) = 0.0
    5 CONTINUE

      IF(RSURFACE.NE.0.0) THEN
      WRITE(3,10) LAMBDA,A,B,AMU1,AMU2,XLARGE,RSURFACE,G
   10 FORMAT(1X,'Irregular particle scatttering run for: ',/,
     .' LAMBDA = ',f6.4,'  A = ',f6.3,'  B = ',f6.4,/,
     .' AMU1 = ',f6.4,'  AMU2 = ',f7.5,/,
     .' X0 = ',f6.4,/,
     .' R = ',f6.4,/,
     .' G = ',f7.3)
      ELSE
      WRITE(3,11) LAMBDA,A,B,AMU1,AMU2
   11 FORMAT(1X,'Mie scattering run for: ',/,
     .' LAMBDA = ',f6.4,'  A = ',f6.3,'  B = ',f6.4,/,
     .' AMU1 = ',f6.4,'  AMU2 = ',f7.5)
      ENDIF

      DO 15 I=1,271
      THETA(I)=MIN(I-1,100)*0.1 + MAX(I-101,0)*1.0
   15 CONTINUE

      IF(RSURFACE.NE.0.0) THEN
C
C     DIFFRACTION
C
      QD = 1.0
C
C     REFLECTION
C
      DO 25 I=1,271
      STHETA = SIN(THETA(I)*RADIANS/2.0)
      SSTHETA = STHETA*STHETA

      XMBAR = AMU1*AMU1 + AMU2*AMU2

      IR(I) = 0.5*((STHETA - SQRT(XMBAR - 1.0 + SSTHETA))/
     .              (STHETA + SQRT(XMBAR - 1.0 + SSTHETA)))**2
     .        + 0.5*((XMBAR*STHETA - SQRT(XMBAR - 1.0 + SSTHETA))/
     .              (XMBAR*STHETA + SQRT(XMBAR - 1.0 + SSTHETA)))**2
   25 CONTINUE

      CALL INTEGRAL(IR,THETA,XINTIR)

      CR = 1.0/XINTIR

      DO 26 I=1,271
      IR(I) = CR*IR(I)
   26 CONTINUE

      QR = 1.0/CR
C
C     TRANSMISSION
C
      BTRANS = -2.0/PI*LOG(G)
      CTRANS = -BTRANS/(2.0*THETA_MIN*RADIANS)
      
      DO 30 I=1,271
        IT(I) = EXP(1.0 + BTRANS*THETA(I)*RADIANS + CTRANS*(THETA(I)*
     &    RADIANS)**2)
   30 CONTINUE

      CALL INTEGRAL(IT,THETA,XINTIT)

      CT = 1.0/XINTIT

      DO 31 I=1,271
      IT(I) = CT*IT(I)
   31 CONTINUE
      ENDIF

      N = NMIEPTS+MOD(NMIEPTS,2)-1

      CALL SIZPARM(A,B,LAMBDA,XMIN,XMAX)

      WRITE(3,35) XMIN,XLARGE,XMAX
   35 FORMAT(' XMIN = ',F9.5,'   X0 = ',F9.5,'   XMAX = ',F9.5)

      DELTA = (XMAX - XMIN)/FLOAT(N-1)
C
C     M = 1 FOR SMALL REGIME
C     M = 2 FOR LARGE REGIME
C
      DO 200 M=1,2

      IF(M .EQ. 1) THEN
      IF(XLARGE .GT. XMAX.OR.RSURFACE.EQ.0.0) THEN
      NUMBER = N
      DELTAX = DELTA
      ELSE
      NUMBER = (XLARGE - XMIN)/DELTA + 1.5
      IF(NUMBER .EQ. NUMBER/2*2) NUMBER = NUMBER + 1
      IF(NUMBER .LT. 7) NUMBER = 7
      DELTAX = (XLARGE - XMIN)/FLOAT(NUMBER-1)
      ENDIF
      RO = XMIN/K
      ELSE
      IF(XLARGE .GT. XMAX.OR.RSURFACE.EQ.0.0) THEN
      NUMBER = 0
      DELTAX = 0.0
      RO = 0.0
      ELSE
      NUMBER = (XMAX - XLARGE)/DELTA + 1.5
      IF(NUMBER .EQ. NUMBER/2*2) NUMBER = NUMBER + 1
      IF(NUMBER .LT. 7) NUMBER = 7
      DELTAX = (XMAX - XLARGE)/FLOAT(NUMBER-1)
      RO = XLARGE/K
      ENDIF
      ENDIF

      DELTAR = DELTAX/K

      R = RO - DELTAR

      IF(NPRNT .GT. 1) THEN
      WRITE(3,40)
   40 FORMAT(///)

      WRITE(3,41)
   41 FORMAT(5X,1HR,10X,1HX,8X,4HQEXT,8X,4HQSCA,8X,4HQABS,8X,6HALBEDO,
     14X,4HN(R),4X,12HN(R)*PI*R**2,3X,3HABS,8X,3HSCA,8X,4HXINT)
      ENDIF

      SUMXNR = 0.0

      SUMX = 0.0

      DO 45 I=1,271
      SUMSS(I) = 0.0
      SUMDX(I) = 0.0
   45 CONTINUE

      SUMSCA = 0.0

      SUMABS = 0.0

      IF(NUMBER .EQ. 0) GO TO 101

      IF(A.EQ.0.) CALL SIZINIT
      DO 100 I=1,NUMBER
      R = R + DELTAR
      XNR=SIZDIS(R,A,B)

      X = R*K

      XNX = XNR/K

      CALL MIEHISS(X,AMU1,AMU2,SS,QEXT,QSCA,QABS,ALBED,0)

      DO 50 J=1,271
      SS(J) = SS(J)*XNR
   50 CONTINUE

      IF(M .EQ. 1) GO TO 53

      DO 51 J=1,271

      IF(J .GT. 181) THEN
      ID(J) = ID(181)
      GO TO 51
      ENDIF

      IF(J .EQ. 1) THEN

      BOZ = 0.5
      ELSE

      ANGLE = THETA(J)
      STHETA = SIN(ANGLE*RADIANS)

      Z = X*STHETA

      CALL BESSEL(Z,1,BESSELZ,IER)

      BOZ = BESSELZ/(X*STHETA)
      ENDIF

      ANGLE = THETA(J)
      CTHETA = COS(ANGLE*RADIANS)
      SCTHETA = CTHETA*CTHETA

      ID(J) = X*X/(4*PI)*(2.0*BOZ)**2*0.5*(1.0 + SCTHETA)
      STHETA = SIN(ANGLE*RADIANS)
C     ID(J)=(2.0*SIN(X*STHETA-PI/4.0)**2*0.5*(1.0 + SCTHETA))/
C    &(PI**2*X*STHETA**3)
   51 CONTINUE

   53 TEMP = PI*R*R*XNR

      SCA = TEMP*QSCA
      ABS = TEMP*QABS

      IF(I .EQ. 1) GO TO 54
      XINT = XINT + DELTAR/2.0*(ABS + ABSOLD)
   54 ABSOLD = ABS

      IF(NPRNT .GT. 1) THEN
      WRITE(3,55) R,X,QEXT,QSCA,QABS,ALBED,XNR,TEMP,ABS,SCA,XINT
   55 FORMAT(1P2E11.3,3E12.5,0PF9.6,1P4E11.3,E12.4)
      ENDIF

      XNRTEMP = PI*R*R*XNR

      XNXTEMP = PI*X*X*XNX

      IF(I.EQ.1.OR.I.EQ.N) THEN
        MULTX=1
      ELSEIF(MOD(I,2).EQ.0) THEN
        MULTX=4
      ELSE
        MULTX=2
      ENDIF

      SUMXNR = SUMXNR + MULTX*XNR
      SUMX = SUMX + MULTX*XNRTEMP
      SUMSCA = SUMSCA + MULTX*SCA
      SUMABS = SUMABS + MULTX*ABS

      DO 60 J=1,271
      SUMSS(J) = SUMSS(J) + MULTX*SS(J)
      IDTEMP=ID(J)
      IF (J.EQ.1) IDTEMP=ID(2)
      SUMDX(J) = SUMDX(J) + MULTX*IDTEMP*XNXTEMP
   60 CONTINUE
  100 CONTINUE

  101 XNSUM = DELTAR/3.0*SUMXNR

      XSUM = DELTAR/3.0*SUMX

      KSCA = DELTAR/3.0*SUMSCA
      KABS = DELTAR/3.0*SUMABS

      IF(NPRNT .GT. 1) THEN
      WRITE(3,110) XNSUM
  110 FORMAT(//,7X,6HN(R) =,E13.6,//)

      WRITE(3,111) XSUM
  111 FORMAT(7X,13HPI*R*R*N(R) =,E13.6,//)
      ENDIF

      IF(XSUM .EQ. 0.0) THEN
      QSCA = KSCA
      ELSE
      QSCA = KSCA/XSUM
      ENDIF

      IF(XNSUM .EQ. 0.0) THEN
      KSCA = KSCA
      ELSE
      KSCA = KSCA/XNSUM
      ENDIF

      IF(NPRNT .GT. 1) THEN
      WRITE(3,112) KSCA
  112 FORMAT(7X,8HK(SCA) =,E13.6,//)

      WRITE(3,113) QSCA
  113 FORMAT(7X,8HQ(SCA) =,E13.6,//)
      ENDIF

      IF(XSUM .EQ. 0.0) THEN
      QABS = KABS
      ELSE
      QABS = KABS/XSUM
      ENDIF

      IF(XNSUM .EQ. 0.0) THEN
      KABS = KABS
      ELSE
      KABS = KABS/XNSUM
      ENDIF

      IF(NPRNT .GT. 1) THEN
      WRITE(3,114) KABS
  114 FORMAT(7X,8HK(ABS) =,E13.6,//)

      WRITE(3,115) QABS
  115 FORMAT(7X,8HQ(ABS) =,E13.6,//)
      ENDIF

      IF(M .EQ. 1) THEN
      DO 116 I=1,271
      SIGSCA(I) = DELTAR/3.0*SUMSS(I)
      SIGSCA(I) = 1.0/(K*K)*SIGSCA(I)/XNSUM
      P(I) = 4.0*PI*SIGSCA(I)/KSCA
  116 CONTINUE

      QSSCA = QSCA
      QSABS = QABS

      SXSUM = XSUM
      SNSUM = XNSUM
      ELSE

      DELTAX = DELTAR*K

      DO 119 I=1,271
      ID(I) = DELTAX/3.0*SUMDX(I)
  119 CONTINUE

      CALL INTEGRAL(ID,THETA,XINTCD)

      IF(XINTCD .EQ. 0.0) THEN
      CD = 1.0
      ELSE
      CD = 1.0/XINTCD
      ENDIF

      DO 21 I=1,271
      ID(I) = CD*ID(I)
   21 CONTINUE

      QLSCA = QSCA
      QLABS = QABS

      LXSUM = XSUM
      LNSUM = XNSUM
      ENDIF

  200 CONTINUE

      QT = QLSCA - QD - QR
C
C     COMPOSITE EFFICIENCES
C
      F = LXSUM/(SXSUM + LXSUM)

      QSTSCA = QLSCA*F*RSURFACE + QSSCA*(1.0-F)
      QSTABS = QLABS*F + QSABS*(1.0-F)
      QSTEXT = QSTSCA + QSTABS

      IF(NPRNT .GT. 1) THEN
      WRITE(3,201) QSTSCA
  201 FORMAT(7X,10HQST(SCA) =,E13.6,//)

      WRITE(3,202) QSTABS
  202 FORMAT(7X,10HQST(ABS) =,E13.6,//)

      WRITE(3,203) QSTEXT
  203 FORMAT(7X,10HQST(EXT) =,E13.6,//)
      ENDIF
C
C     COMPOSITE PHASE FUNCTION:
C
      IF(XLARGE .GT. XMAX.OR.RSURFACE.EQ.0.0) THEN
      DO 209 I=1,271
      CP(I) = P(I)
  209 CONTINUE
      ELSE
      DO 210 I=1,271
      CP(I) = P(I)*(1.0-F)*QSSCA/QSTSCA + RSURFACE*F*QLSCA/QSTSCA*
     .(ID(I)*QD/QLSCA + IR(I)*QR/QLSCA + IT(I)*QT/QLSCA)
  210 CONTINUE
      ENDIF

      KSTSCA = QSTSCA*(SXSUM + LXSUM)/(SNSUM + LNSUM)
      KSTABS = QSTABS*(SXSUM + LXSUM)/(SNSUM + LNSUM)
      KSTEXT = KSTSCA + KSTABS

      IF(NPRNT .GT. 1) THEN
      WRITE(3,211) KSTSCA
  211 FORMAT(7X,10HKST(SCA) =,E13.6,//)

      WRITE(3,212) KSTABS
  212 FORMAT(7X,10HKST(ABS) =,E13.6,//)

      WRITE(3,213) KSTEXT
  213 FORMAT(7X,10HKST(EXT) =,E13.6,//)
      ENDIF

      WM = KSTSCA/KSTEXT

      IF(NPRNT .GT. 1) THEN
      WRITE(3,215) WM
  215 FORMAT(7X,3HW =,E13.6,//)

      WRITE(3,216) CD,CR,CT
  216 FORMAT(7X,4HCD =,E13.6,2X,4HCR =,E13.6,2X,4HCT =,E13.6,//)

      WRITE(3,217) QD,QR,QT
  217 FORMAT(7X,4HQD =,E13.6,2X,4HQR =,E13.6,2X,4HQT =,E13.6,//)
      ENDIF

      IF(NPRNT .GT. 0) THEN
      WRITE(3,40)

      WRITE(3,220)
  220 FORMAT(11X,5HTHETA,9X,8HP(THETA),6X,9HID(THETA),6X,9HIR(THETA),
     .6X,9HIT(THETA),6X,9HCP(THETA),4X,14HLOG(CP(THETA)))

      DO 225 I=1,271
      TEMP = LOG10(CP(I))
      WRITE(3,224) THETA(I),P(I),ID(I),IR(I),IT(I),CP(I),TEMP
  224 FORMAT(5X,1P7E15.6)
  225 CONTINUE

      CALL INTEGRA1(CP,THETA,GTEMP)

      WRITE(3,40)
      WRITE(3,181) GTEMP
  181 FORMAT(12X,3HG =,E13.6,//)

      CALL INTEGRAL(CP,THETA,GTEST)

      WRITE(3,182) GTEST
  182 FORMAT(8X,7HGTEST =,E13.6)
      ENDIF

      RETURN
      END
      SUBROUTINE SIZPARM(A,B,LAMBDA,XMIN,XMAX)
C
C     THIS SUBROUTINE COMPUTES XMIN AND DELTAX FOR A STANDARD HANSEN
C     DISTRIBUTION.  IT SOLVES FOR RMIN AND RMAX, THE RADII AT
C     WHICH THE DISTRIBUTION REACHES ONE MILLIONTH OF ITS PEAK
C     VALUE.  THE REGION BETWEEN RMIN AND RMAX IS SUBDIVIDED INTO N
C     INTERVALS FOR SIMPSON'S RULE INTEGRATION IN THE MAIN PROGRAM.
C
      REAL LAMBDA
C
C     THIS STATEMENT FUNCTION  IS BASED ON NEWTON'S METHOD AND SHOWS
C     HOW TO ITERATE TO OBTAIN IMPROVED GUESSES FOR RMIN OR RMAX:
C
      PI = 3.14159265358979D0
      IF(A.EQ.0.D0) THEN
        CALL SIZLIM(RMIN,RMAX)
        XMIN=2.D0*PI*RMIN/LAMBDA
        XMAX=2.D0*PI*RMAX/LAMBDA
        RETURN
      ENDIF
      D = 1.0D-4

C     COMPUTE RADIUS FOR WHICH SIZE DISTRIBUTION IS MAXIMUM
C     AND SIZE DISTRIBUTION VALUE AT MAXIMUM.

      RMAX = A*(1.0D0 - 3.0D0*B)

C     GUESS MINIMUM R VALUE NEEDED

      IF(RMAX.GT.0.0) THEN
        R1 = LOG10(RMAX) - 1.0D0
        R1 = EXP(R1*LOG(10.0D0))
      ELSE
        R1 = 1.0D-10
C       R1 = 1.0D-3
      ENDIF
      
      ITER=0

C     ITERATE NEWTON'S METHOD SOLUTION FOR RMIN

   10 IF(B.LT.1.D0/3.D0) THEN
        R2 = R1-((1.0D0-3.0D0*B)/B*(1.0D0-LOG(A*(1-3.0D0*B))+LOG(R1)) -
     .    R1/A/B-LOG(D))/((1.0D0-3.0D0*B)/B/R1-1.0D0/A/B)
      ELSE
        R2 = R1
      ENDIF
      ITER=ITER+1
      IF(ABS((R2 - R1)/R1) .GT. 1.0E-3 .AND. ITER .LT. 100) THEN
        R1 = MAX(R2,1.0D-10)
        GO TO 10
      ELSE
        R2 = R1
      ENDIF
      RMIN = R2

C     GUESS MAXIMUM R VALUE NEEDED

      IF(B.LT.1./3.) THEN
        R1 = LOG10(RMAX) + 0.05D0
        R1 = EXP(R1*LOG(10.0D0))
      ELSE
        R1 = A
      ENDIF

C     ITERATE NEWTON'S METHOD SOLUTION FOR RMAX

   20 IF(B.LT.1.D0/3.D0) THEN
        R2 = R1-((1.0D0-3.0D0*B)/B*(1-LOG(A*(1-3.0D0*B))+LOG(R1)) -
     .    R1/A/B-LOG(D))/((1-3.0D0*B)/B/R1-1.0D0/A/B)
      ELSE
        X1=(1.D0-3.D0*B)/B
        X2=-R1/(A*B)
        R2 = R1-(R1**X1*EXP(X2)-D)/(R1**(X1)*X2+EXP(X2)*X1)
      ENDIF
      IF(ABS((R2 - R1)/R1) .GT. 1.0D-3) THEN
      R1 = MAX(R2,1.0D-04)
      GO TO 20
      ENDIF
      RMAX = R2
C     RMAX = 10.0D0

      XMIN = 2.0D0*PI*RMIN/LAMBDA
      XMAX = 2.0D0*PI*RMAX/LAMBDA

      RETURN
      END
      FUNCTION SIZDIS(R,A,B)
      PARAMETER (E=2.718282,ALOGE=0.4342945)
      IF(A.NE.0.) THEN
        IF(B.LT.1.0/3.0) THEN
          XNR = EXP(((1.0-3.0*B)/B*LOG10((R*E)/(A*(1.0-3.0*B)))-
     .      R/A/B*ALOGE)*LOG(10.0))
        ELSE
          XNR = R**((1.0-3.0*B)/B)*EXP(-R/(A*B))
        ENDIF
      ELSE
        CALL SIZTAB(R,XNR)
      ENDIF
      SIZDIS=XNR
      END
      SUBROUTINE DEFRAD(NVBIN,RADIUS,RADMIN,RADMAX)
      PARAMETER (PI=3.14159265358979D0)
      DIMENSION RADIUS(*),RADMIN(*),RADMAX(*)
      DIMENSION V(42),VM(42)
C
C         GENERATE V AND VM VALUES
C
      VM(1)=4.1887902D-06
      V(1)=2.7925268D-06
      DO 2 J=2,NVBIN
      V(J)= V(J-1)*2.D0
      VM(J)= VM(J-1)*2.D0
  2   CONTINUE
      V(NVBIN+1)=V(NVBIN)*2.D0
C
C         COMPUTE RADII
C
      CONST=3./PI/4.
      DO 3 J=1,NVBIN
      RADIUS(J)=LOG10((CONST*VM(J))**(1./3.))
      RADMIN(J)=(CONST*V(J))**(1./3.)
      RADMAX(J)=(CONST*V(J+1))**(1./3.)
    3 CONTINUE
      END
      SUBROUTINE CLOUDFIL(LAYER,STRUCFN,DELP)
      PARAMETER (NUMLAYERS=32)
      CHARACTER STRUCFN*(*),SIZFN*255
C     REAL NMOL
      DIMENSION PTOP(50),PBTM(50)
C     DIMENSION N(50)
      COMMON/SIZD/SIZFN,LAYER1(NUMLAYERS),LAYER2(NUMLAYERS)

C     If first call, we must open the file
      IF(LAYER.EQ.1) THEN
        OPEN(8,FILE=STRUCFN,STATUS='OLD')
        READ(8,'(/)')
c     Maximum of 50 layers allowed
        DO 10 I=1,50
   10   READ(8,'(I4,T25,F10.0,T35,F10.0)',END=99) IMAX,PTOP(I),PBTM(I)
        WRITE(6,5038) STRUCFN
5038    format(' Too many layers in structure file ',A)
        STOP 'Too many layers'
   99   CONTINUE
      ENDIF

      IF(LAYER1(LAYER).GT.IMAX.OR.LAYER2(LAYER).GT.IMAX) THEN
        WRITE(6,5039) STRUCFN,LAYER1(LAYER),LAYER2(LAYER)
5039  format (' Specified layer number exceeds those in ',
     &  'structure file ',A,'.  LAYER1 = ',I2,' and LAYER2 = '
     &  I2)
        STOP 'LAYER1 or LAYER 2 too large'
      ENDIF

      IF(LAYER2(LAYER).EQ.0.OR.LAYER1(LAYER).EQ.0) THEN
        DELP=0.0D0
      ELSE
        DELP=(PBTM(LAYER2(LAYER))-PTOP(LAYER1(LAYER)))/1000.
      ENDIF

C     NMOL=0.
C     DO 20 J=LAYER1(LAYER),LAYER2(LAYER)
C  20 NMOL=NMOL+N(J)

      CLOSE(8)

      END
      SUBROUTINE CLOUDML(LAYER,STRUCFN,DELP)
      PARAMETER (NUMLAYERS=32)
      CHARACTER STRUCFN*(*),SIZFN*255
C     REAL NMOL
      DIMENSION PTOP(50),PBTM(50)
C     DIMENSION N(50)
      COMMON/SIZD/SIZFN,LAYER1(NUMLAYERS),LAYER2(NUMLAYERS)

C     If first call, we must open the file
      IF(LAYER.EQ.1) THEN
        OPEN(8,FILE=STRUCFN,STATUS='OLD')
        READ(8,'(/)')
c     Maximum of 50 layers allowed
        DO 10 I=1,50
   10   READ(8,'(I3,20X,2F10.0)',END=99) IMAX,PTOP(I),PBTM(I)
        WRITE(6,5038) STRUCFN
5038    format(' Too many layers in structure file ',A)
        STOP 'Too many layers'
   99   CONTINUE
      ENDIF

      IF(LAYER1(LAYER).GT.IMAX.OR.LAYER2(LAYER).GT.IMAX) THEN
        WRITE(6,5039) STRUCFN,LAYER1(LAYER),LAYER2(LAYER)
5039  format (' Specified layer number exceeds those in ',
     &  'structure file ',A,'.  LAYER1 = ',I2,' and LAYER2 = '
     &  I2)
        STOP 'LAYER1 or LAYER 2 too large'
      ENDIF

      DELP=(PBTM(LAYER2(LAYER))-PTOP(LAYER1(LAYER)))/1000.

C     NMOL=0.
C     DO 20 J=LAYER1(LAYER),LAYER2(LAYER)
C  20 NMOL=NMOL+N(J)

      CLOSE(8)

      END
      SUBROUTINE INTEGRAL(P,THETA,GTEST)
      DIMENSION P(271),THETA(271)

      PI = 3.14159265358979
      RADIANS = PI/180.0

      TEST1 = 0.0
      TEST2 = 0.0
      TEST3 = 0.0

      DO 150 I=1,101

      TEST = P(I)*SIN(THETA(I)*RADIANS)

      IF(I .NE. 1 .AND. I .NE. 101) GO TO 130
      TEST1 = TEST1 + TEST
      GO TO 150

  130 IF(I .NE. I/2*2) GO TO 140
      TEST2 = TEST2 + 4.0*TEST
      GO TO 150

  140 TEST3 = TEST3 + 2.0*TEST
  150 CONTINUE

      DELTA = 0.1*RADIANS
      GTEST = DELTA/3.0*(TEST1 + TEST2 + TEST3)

      TEST1 = 0.0
      TEST2 = 0.0
      TEST3 = 0.0

      DO 180 I=101,271

      TEST = P(I)*SIN(THETA(I)*RADIANS)

      IF(I .NE. 102 .AND. I .NE. 271) GO TO 160
      TEST1 = TEST1 + TEST
      GO TO 180

  160 IF(I .NE. I/2*2) GO TO 170
      TEST2 = TEST2 + 4.0*TEST
      GO TO 180

  170 TEST3 = TEST3 + 2.0*TEST
  180 CONTINUE

      DELTA = 1.0*RADIANS
      GTEST = 0.5*(GTEST + DELTA/3.0*(TEST1 + TEST2 + TEST3))

      RETURN
      END
      SUBROUTINE INTEGRA1(P,THETA,GTEST)
      DIMENSION P(271),THETA(271)

      PI = 3.14159265358979
      RADIANS = PI/180.0

      TEST1 = 0.0
      TEST2 = 0.0
      TEST3 = 0.0

      DO 150 I=1,101

      TEST = P(I)*SIN(THETA(I)*RADIANS)*COS(THETA(I)*RADIANS)

      IF(I .NE. 1 .AND. I .NE. 101) GO TO 130
      TEST1 = TEST1 + TEST
      GO TO 150

  130 IF(I .NE. I/2*2) GO TO 140
      TEST2 = TEST2 + 4.0*TEST
      GO TO 150

  140 TEST3 = TEST3 + 2.0*TEST
  150 CONTINUE

      DELTA = 0.1*RADIANS
      GTEST = DELTA/3.0*(TEST1 + TEST2 + TEST3)

      TEST1 = 0.0
      TEST2 = 0.0
      TEST3 = 0.0

      DO 180 I=101,271

      TEST = P(I)*SIN(THETA(I)*RADIANS)*COS(THETA(I)*RADIANS)

      IF(I .NE. 102 .AND. I .NE. 271) GO TO 160
      TEST1 = TEST1 + TEST
      GO TO 180

  160 IF(I .NE. I/2*2) GO TO 170
      TEST2 = TEST2 + 4.0*TEST
      GO TO 180

  170 TEST3 = TEST3 + 2.0*TEST
  180 CONTINUE

      DELTA = 1.0*RADIANS
      GTEST = 0.5*(GTEST + DELTA/3.0*(TEST1 + TEST2 + TEST3))

      RETURN
      END
      SUBROUTINE MIEHISS(X,AMU1,AMU2,SS,QEXT,QSCA,QABS,ALBED,Koutput)
      PARAMETER (NMAX=2100)
      DIMENSION P(NMAX),Q(NMAX),R(NMAX)
      DIMENSION AR(NMAX),AI(NMAX),BR(NMAX),BI(NMAX)
      DIMENSION SS(271)

C     MIE THEORY OF SCATTERING BY HOMOGENEOUS ISOTROPIC SINGLE SMOOTH
C     SPHERES.

      RADIANS = 3.14159265358979/180.0

      IF(AMU1 .LE. 0.0) RETURN

      IF(Koutput .EQ. 0) GO TO 90

      WRITE(3,500)
  500 FORMAT(1H1)

      WRITE(3,510)
  510 FORMAT(5X,119H----------------------------------------------------
     1------------------------------------------------------------------
     2-)

      WRITE(3,520) AMU1,AMU2
  520 FORMAT(22X,19HINDEX OF REFRACTION,2X,10HREAL PART=,F14.10,6X,16H-I
     1MAGINARY PART=,F14.10,/)

      WRITE(3,510)

      WRITE(3,540)

   90 Y1 = X*AMU1
      Y2 = -X*AMU2
      YY = Y1*Y1 + Y2*Y2
      NYY = SQRT(YY) + 50.0
      IF(AMU1 .LT. 1.0) NYY = FLOAT(NYY) + X*(1.0 - AMU1)
      NX = NYY
      IF(NYY .GT. NMAX) NX = NMAX

      IF(AMU2 .GT. 0.0) GO TO 100
      N = FLOAT(NYY) + 0.75*X + 50.0
      GO TO 101
  100 N = FLOAT(NX) + 0.75*X + 50.0

  101 PJN1 = 0.0
      QJN1 = 0.0
      RJN1 = 0.0

      CX = COS(X)
      SX = SIN(X)

      C = CX/X + SX
      CQ = CX/C

      DO 110 I=1,N
      JN = N - I + 1
      XN = FLOAT(2*JN + 1)

      PR = (XN*Y1/YY) - PJN1
      PI = (XN*Y2/YY) + QJN1
      TEMP = PR*PR + PI*PI
      RJN = X/(XN - X*RJN1)
      PJN = PR/TEMP
      QJN = PI/TEMP
      IF(JN .GT. NMAX) GO TO 105

      P(JN) = PJN
      Q(JN) = QJN
      R(JN) = RJN

  105 PJN1 = PJN
      QJN1 = QJN
      RJN1 = RJN

  110 CONTINUE

      TXE = 0.0
      SCA = 0.0

      DO 120 NS=1,NX
      CN = FLOAT(NS)
      IF(NS .GT. 1) GO TO 114
      S = R(1)*SX
      DCX = CX - C/X
      GO TO 115
  114 S = R(NS)*S
      XN = 2*NS - 1
      QC = X/(XN - X*CQ)
      TEMP = C/QC
      DCX = C - CN*(TEMP/X)
      C = TEMP
      CQ = QC
  115 PQ = P(NS)*P(NS) + Q(NS)*Q(NS)
      ZR1 = (P(NS)/PQ) - CN*(Y1/YY)
      ZI1 = CN*(Y2/YY) - Q(NS)/PQ
      X1 = (1.0/R(NS)) - CN/X
      ZR2 = 1.0
      ZI2 = C/S
      ZR3 = X1
      ZI3 = DCX/S
      ANR = ZR1 - X1*AMU1
      ANI = ZI1 + X1*AMU2
      ADR = ZR1 - ZI1*ZI2 - AMU1*X1 - AMU2*ZI3
      ADI = ZR1*ZI2 + ZI1 - AMU1*ZI3 + AMU2*X1
      BNR = AMU1*ZR1 + AMU2*ZI1 - X1
      BNI = AMU1*ZI1 - AMU2*ZR1
      XR = ZR1 - ZI1*ZI2
      XI = ZR1*ZI2 + ZI1
      BDR = AMU1*XR + AMU2*XI - ZR3
      BDI = AMU1*XI - AMU2*XR - ZI3
      TEMP = ADR*ADR + ADI*ADI
      ARNS = (ANR*ADR + ANI*ADI)/TEMP
      AINS = (ANI*ADR - ANR*ADI)/TEMP
      TEMP = BDR*BDR + BDI*BDI
      BRNS = (BNR*BDR + BNI*BDI)/TEMP
      BINS = (BNI*BDR - BNR*BDI)/TEMP
      AR(NS) = ARNS
      AI(NS) = AINS
      BR(NS) = BRNS
      BI(NS) = BINS
      RN = CN + 0.5
      TXE = TXE + RN*(ARNS + BRNS)
      SCA = SCA + RN*(ARNS*ARNS + AINS*AINS + BRNS*BRNS + BINS*BINS)
      TEMP = RN*(ARNS + BRNS)/TXE
      TEMP = TEMP*TEMP
      IF(NS .GT. 1 .AND. TEMP .LE. 0.1E-21) GO TO 130
  120 CONTINUE

      WRITE(3,125) X
  125 FORMAT(3X,8HFOR X = ,1PE11.3,2X,17HMORE TERMS NEEDED)

  130 N = 101
      DELTA = 0.1
      THETA = 0.0

      XX = 4.0/(X*X)
      QEXT = XX*TXE
      QSCA = XX*SCA
      QABS = QEXT - QSCA
      ALBED = QSCA/QEXT

      NN = CN

      J = 0

  135 DO 150 I=1,N

      CTHETA = COS(THETA*RADIANS)

      PI = 0.0
      PI1 = 1.0
      S1R = 1.5*(AR(1) + CTHETA*BR(1))
      S1I = 1.5*(AI(1) + CTHETA*BI(1))
      S2R = 1.5*(AR(1)*CTHETA + BR(1))
      S2I = 1.5*(AI(1)*CTHETA + BI(1))

      DO 140 M=2,NN
      FN = FLOAT(M)
      FNN = (2.0*FN + 1.0)/(FN*(FN + 1.0))
      PI2 = (CTHETA*(2.0*FN - 1.0)*PI1 - FN*PI)/(FN - 1.0)
      TAU2 = FN*CTHETA*PI2 - (FN + 1.0)*PI1

      S1R = S1R + FNN*(AR(M)*PI2 + BR(M)*TAU2)
      S1I = S1I + FNN*(AI(M)*PI2 + BI(M)*TAU2)
      S2R = S2R + FNN*(AR(M)*TAU2 + BR(M)*PI2)
      S2I = S2I + FNN*(AI(M)*TAU2 + BI(M)*PI2)

      PI = PI1
      PI1 = PI2
  140 CONTINUE

      SS1 = S1R*S1R + S1I*S1I
      SS2 = S2R*S2R + S2I*S2I
      TEMP = SS1 + SS2
      POLAR = (SS1 - SS2)/TEMP
      J = J + 1
      SS(J) = 0.5*TEMP

      IF(Koutput .EQ. 0) GO TO 145

      WRITE(3,540) X,THETA,SS1,SS2,SS(J),POLAR
  540 FORMAT(9X,7(2X,E12.5),1X,I6)

  145 THETA = THETA + DELTA

  150 CONTINUE

      IF(THETA .GT. 179.9999) GO TO 999

      N = 170
      THETA = THETA - DELTA
      DELTA = 1.0
      THETA = THETA + DELTA
      GO TO 135

  999 IF(Koutput .EQ. 0) RETURN
      WRITE(3,510)

      RETURN
      END
      SUBROUTINE BESSEL(X,N,BORDER,IER)
C
C     LATEST REVISION    OCTOBER 1978
C
C     PURPOSE            TO CALCULATE J BESSEL FUNCTIONS FOR REAL
C                       ARGUMENT AND INTEGER ORDER
C
C     USAGE              CALL BESJR (X,N,B,IER)
C
C     INPUT ARGUMENTS    X
C                         REAL ARGUMENT FOR WHICH J BESSEL FUNCTIONS
C                         ARE TO BE CALCULATED.
C
C                       N
C                         INTEGER, THE HIGHEST ORDER TO BE CALCULATED.
C                         N MUST BE GREATER THAN OR EQUAL TO ZERO.
C
C     OUTPUT ARGUMENTS   B
C                         REAL VECTOR OF LENGTH N+1 CONTAINING THE
C                         BESSEL FUNCTION VALUES J-SUB-0(X),
C                         ,J-SUB-1(X),...,J-SUB-N(X) IN B(1),
C                         B(2),...,B(N+1).
C
C                       IER
C                         AN INTEGER ERROR FLAG.
C                         =0 IF ALL DESIRED ORDERS HAVE BEEN
C                            CALCULATED SATISFACTORILY,
C                         =1 IF ABS(X) IS TOO LARGE,
C                         =2 IF N IS LESS THAN ZERO,
C                         =2+K IF ONLY THE FIRST K RESULTS ARE
C                               CORRECT.
C                            IN THE RETURNED VALUES B(M) FOR M
C                            GREATER THAN K, APPROXIMATELY THE LAST
C                            ALOG10(ABS(B(M)/B(K))) SIGNIFICANT
C                            DIGITS ARE IN ERROR.
C
C     ENTRY POINTS       BESJR
C
C     PRECISION          SINGLE
C
C     SPECIALIST         RUSS REW, NCAR, BOULDER, COLORADO
C
C     ACCURACY           IN TESTS RUN ON THE NCAR 7600 WITH ORDERS
C                       FROM 0 THROUGH 10 AND WITH 2500 RANDOM VALUES
C                       OF THE ARGUMENT BETWEEN 0 AND 50, THE MAXIMUM
C                       RELATIVE ERROR (OR ABSOLUTE ERROR WHEN IT WAS
C                       LARGER, NEAR ZEROS OF THE J BESSEL FUNCTION)
C                       OBSERVED WAS 3.5E-14.
C
C     TIMING             ON THE NCAR 7600, BESJR TAKES ABOUT
C                       0.11+0.006*N MILLISECONDS WHEN X=1.0.
C
C     PORTABILITY        ANSI 1966 STANDARD
C
      DIMENSION B(2)
      DATA IORJ/0/
      NB = N+1
      CALL B2SLRI (X,N+1,IORJ,B,NCALC)
      BORDER = B(N+1)
      IER = 0
      IF (NCALC .EQ. NB) GO TO 103
      IF (NCALC .GE. 0) GO TO 102
      IF (N .GE. 0) GO TO 101
      IER = 2
      WRITE(6,5042)
5042  format(25H IN BESJR, N OUT OF RANGE)
      GO TO 103
  101 IER = 1
      WRITE(6,5043)
5043  format(25H IN BESJR, X OUT OF RANGE)
      GO TO 103
  102 IER = 2+NCALC
      WRITE(6,5044)
5044  format(40H IN BESJR, ACCURACY LOST FOR SOME ORDERS)
  103 RETURN
      END
      SUBROUTINE B2SLRI (X,NB,IZE,B,NCALC)
C
C     THIS ROUTINE CALCULATES BESSEL FUNCTIONS I AND J OF REAL
C     ARGUMENT AND INTEGER ORDER.
C
C
C     EXPLANATION OF VARIABLES IN THE CALLING SEQUENCE
C
C     X     REAL (SINGLE PRECISION) ARGUMENT FOR WHICH I*S OR J*S
C          ARE TO BE CALCULATED.  IF I*S ARE TO BE CALCULATED,
C          ABS(X) MUST BE LESS THAN EXPARG (WHICH SEE BELOW).
C     NB    INTEGER TYPE.  1 + HIGHEST ORDER TO BE CALCULATED.
C          IT MUST BE POSITIVE.
C     IZE   INTEGER TYPE.  ZERO IF J*S ARE TO BE CALCULATED, 1
C          IF I*S ARE TO BE CALCULATED.
C     B     REAL VECTOR OF LENGTH NB, NEED NOT BE
C          INITIALIZED BY USER.  IF THE ROUTINE TERMINATES
C          NORMALLY (NCALC=NB), IT RETURNS J(OR I)-SUB-ZERO
C          THROUGH J(OR I)-SUB-NB-MINUS-ONE OF X IN THIS
C          VECTOR.
C    NCALC  INTEGER TYPE, NEED NOT BE INITIALIZED BY USER.
C          BEFORE USING THE RESULTS, THE USER SHOULD CHECK THAT
C          NCALC=NB, I.E. ALL ORDERS HAVE BEEN CALCULATED TO
C          THE DESIRED ACCURACY.  SEE ERROR RETURNS BELOW.
C
C
C     EXPLANATION OF MACHINE-DEPENDENT CONSTANTS
C
C     NSIG  DECIMAL SIGNIFICANCE DESIRED.  SHOULD BE SET TO
C          IFIX(ALOG10(2)*NBIT+1), WHERE NBIT IS THE NUMBER OF
C          BITS IN THE MANTISSA OF A REAL VARIABLE.
C          SETTING NSIG LOWER WILL RESULT IN DECREASED ACCURACY
C          WHILE SETTING NSIG HIGHER WILL INCREASE CPU TIME
C          WITHOUT INCREASING ACCURACY.  THE TRUNCATION ERROR
C          IS LIMITED TO T=.5*10**-NSIG FOR J*S OF ORDER LESS
C          THAN ARGUMENT, AND TO A RELATIVE ERROR OF T FOR
C          I*S AND THE OTHER J*S.
C     NTEN  LARGEST INTEGER K SUCH THAT 10**K IS MACHINE-
C          REPRESENTABLE IN REAL.
C     LARGEX  UPPER LIMIT ON THE MAGNITUDE OF X.  BEAR IN MIND
C            THAT IF ABS(X)=N, THEN AT LEAST N ITERATIONS OF THE
C            BACKWARD RECURSION WILL BE EXECUTED.
C     EXPARG  LARGEST REAL ARGUMENT THAT THE LIBRARY
C            EXP ROUTINE CAN HANDLE.
C
C
C     ERROR RETURNS
C
C     LET G DENOTE EITHER I OR J.
C
C     IN CASE OF AN ERROR, NCALC.NE.NB, AND NOT ALL G*S
C     ARE CALCULATED TO THE DESIRED ACCURACY.
C
C     IF NCALC.LT.0, AN ARGUMENT IS OUT OF RANGE.  NB.LE.0
C     OR IZE IS NEITHER 0 NOR 1 OR IZE=1 AND ABS(X).GE.EXPARG.
C     IN THIS CASE, THE B-VECTOR IS NOT CALCULATED, AND NCALC
C     IS SET TO MIN0(NB,0)-1 SO NCALC.NE.NB.
C
C     NB.GT.NCALC.GT.0 WILL OCCUR IF NB.GT.MAGX AND ABS(G-
C     SUB-NB-OF-X/G-SUB-MAGX+NP-OF-X).LT.10.**(NTEN/2), I.E. NB
C     IS MUCH GREATER THAN MAGX.  IN THIS CASE, B(N) IS CALCU-
C     LATED TO THE DESIRED ACCURACY FOR N.LE.NCALC, BUT FOR
C     NCALC.LT.N.LE.NB, PRECISION IS LOST.  IF N.GT.NCALC AND
C     ABS(B(NCALC)/B(N)).EQ.10**-K, THEN THE LAST K SIGNIFICANT
C     FIGURES OF B(N) ARE ERRONEOUS.  IF THE USER WISHES TO
C     CALCULATE B(N) TO HIGHER ACCURACY, HE SHOULD USE AN
C     ASYMPTOTIC FORMULA FOR LARGE ORDER.
C
      REAL      X        ,B        ,P        ,TEST     ,TEMPA   ,
     1          TEMPB    ,TEMPC    ,EXPARG   ,SIGN     ,SUM     ,
     2          TOVER    ,PLAST    ,POLD     ,PSAVE    ,PSAVEL
      DIMENSION B(NB)
      DATA NSIG,NTEN,LARGEX,EXPARG/8,74,1000000,180.00E0/
      TEMPA = ABS(X)
      MAGX = INT((TEMPA))
      IF(NB .GT. 0 .AND. MAGX .LE. LARGEX .AND.
     1  (IZE.EQ.0 .OR. (IZE.EQ.1 .AND. TEMPA.LE.EXPARG))) GO TO 101
C
C     ERROR RETURN -- X,NB,OR IZE IS OUT OF RANGE
C
      NCALC = MIN0(NB,0) - 1
      RETURN
  101 SIGN = (FLOAT(1-2*IZE))
      NCALC = NB
C
C     USE 2-TERM ASCENDING SERIES FOR SMALL X
C
      IF (TEMPA**4 .LT. .1E0**NSIG) GO TO 123
C
C     INITIALIZE THE CALCULATION OF P*S
C
      NBMX = NB-MAGX
      N = MAGX+1
      PLAST = 1.E0
      P = (FLOAT(2*N))/TEMPA
C
C     CALCULATE GENERAL SIGNIFICANCE TEST
C
      TEST = 2.E0*1.E1**NSIG
      IF (IZE.EQ.1 .AND. 2*MAGX.GT.5*NSIG) TEST = SQRT(TEST*P)
      IF (IZE.EQ.1 .AND. 2*MAGX.LE.5*NSIG) TEST = TEST/1.585**MAGX
      M = 0
      IF (NBMX .LT. 3) GO TO 103
C
C     CALCULATE P*S UNTIL N=NB-1.  CHECK FOR POSSIBLE OVERFLOW.
C
C     THE FOLLOWING DEVIOUS COMPUTATION REPLACES
C     TOVER=10.0**(NTEN-NSIG)
C     AND IS NECESSITATED BY THE POOR POWER ALGORITHM ON THE NCAR 7600
C     IN ORDER TO PREVENT OVERFLOW
C
      INTEMP = NTEN-NSIG
      INHLF = INTEMP/2
      TOVER = 10.0**INHLF*10.0**(INTEMP-INHLF)
      NSTART = MAGX+2
      NEND = NB-1
      DO 102 N=NSTART,NEND
      POLD = PLAST
      PLAST = P
      P = (FLOAT(2*N))*PLAST/TEMPA-SIGN*POLD
      IF (P-TOVER) 102,102,104
  102 CONTINUE
C
C     CALCULATE SPECIAL SIGNIFICANCE TEST FOR NBMX.GT.2.
C
      TEST = MAX(TEST,SQRT(PLAST*1.E1**NSIG)*SQRT(2.E0*P))
C
C     CALCULATE P*S UNTIL SIGNIFICANCE TEST PASSES
C
  103 N = N+1
      POLD = PLAST
      PLAST = P
      P = (FLOAT(2*N))*PLAST/TEMPA-SIGN*POLD
      IF (P .LT. TEST) GO TO 103
      IF (IZE.EQ.1 .OR. M.EQ.1) GO TO 109
C
C     FOR J*S, A STRONG VARIANT OF THE TEST IS NECESSARY.
C     CALCULATE IT, AND CALCULATE P*S UNTIL THIS TEST IS PASSED.
C
      M = 1
      TEMPB = P/PLAST
      TEMPC = (FLOAT(N+1))/TEMPA
      IF (TEMPB+1.E0/TEMPB .GT. 2.E0*TEMPC)
     1    TEMPB = TEMPC+SQRT(TEMPC**2-1.E0)
      TEST = TEST/SQRT(TEMPB-1.E0/TEMPB)
      IF (P-TEST) 103,109,109
C
C     TO AVOID OVERFLOW, DIVIDE P*S BY TOVER.  CALCULATE P*S
C     UNTIL ABS(P).GT.1.
C
C     HERE IS THAT DEVIOUS COMPUTATION AGAIN, THIS TIME TO REPLACE
C 104 TOVER=10.0**NTEN
C
  104 INHLF = NTEN/2
      TOVER = 10.0**INHLF*10.0**(NTEN-INHLF)
      P = P/TOVER
      PLAST = PLAST/TOVER
      PSAVE = P
      PSAVEL = PLAST
      NSTART = N+1
  105 N = N+1
      POLD = PLAST
      PLAST = P
      P = (FLOAT(2*N))*PLAST/TEMPA-SIGN*POLD
      IF (P .LE. 1.E0) GO TO 105
      TEMPB = (FLOAT(2*N))/TEMPA
      IF (IZE .EQ. 1) GO TO 106
      TEMPC = .5E0*TEMPB
      TEMPB = PLAST/POLD
      IF(TEMPB+1.E0/TEMPB .GT. 2.E0*TEMPC)
     1    TEMPB = TEMPC+SQRT(TEMPC**2-1.E0)
C
C     CALCULATE BACKWARD TEST, AND FIND NCALC, THE HIGHEST N
C     SUCH THAT THE TEST IS PASSED.
C
  106 TEST = .5E0*POLD*PLAST*(1.E0-1.E0/TEMPB**2)/1.E1**NSIG
      P = PLAST*TOVER
      N = N-1
      NEND = MIN0(NB,N)
      DO 107 NCALC=NSTART,NEND
      POLD = PSAVEL
      PSAVEL = PSAVE
      PSAVE = (FLOAT(2*N))*PSAVEL/TEMPA-SIGN*POLD
      IF (PSAVE*PSAVEL-TEST) 107,107,108
  107 CONTINUE
      NCALC = NEND+1
  108 NCALC = NCALC-1
C
C     THE SUM B(1)+2B(3)+2B(5)... IS USED TO NORMALIZE.  M, THE
C     COEFFICIENT OF B(N), IS INITIALIZED TO 2 OR 0.
C
  109 N = N+1
      M = 2*N-4*(N/2)
C
C     INITIALIZE THE BACKWARD RECURSION AND THE NORMALIZATION SUM
C
      TEMPB = 0.E0
      TEMPA = 1.E0/P
      SUM = (FLOAT(M))*TEMPA
      NEND = N-NB
      IF (NEND) 114,112,110
C
C     RECUR BACKWARD VIA DIFFERENCE EQUATION, CALCULATING (BUT
C     NOT STORING) B(N), UNTIL N=NB.
C
  110 DO 111 L=1,NEND
      N = N-1
      TEMPC = TEMPB
      TEMPB = TEMPA
      TEMPA = ((FLOAT(2*N))*TEMPB)/X-SIGN*TEMPC
      M = 2-M
      SUM = SUM+(FLOAT(M))*TEMPA
  111 CONTINUE
C
C     STORE B(NB)
C
  112 B(N) = TEMPA
      IF (NB .GT. 1) GO TO 113
C
C     NB=1.  SINCE 2*TEMPA WAS ADDED TO THE SUM, TEMPA MUST BE
C     SUBTRACTED
C
      SUM = SUM-TEMPA
      GO TO 120
C
C     CALCULATE AND STORE B(NB-1)
C
  113 N = N-1
      B(N) = ((FLOAT(2*N))*TEMPA)/X-SIGN*TEMPB
      IF(N .EQ. 1) GO TO 119
      M = 2-M
      SUM = SUM+(FLOAT(M))*B(N)
      GO TO 116
C
C     N.LT.NB, SO STORE B(N) AND SET HIGHER ORDERS TO ZERO
C
  114 B(N) = TEMPA
      NEND = -NEND
      DO 115 L=1,NEND
      B(N+L) = 0.E0
  115 CONTINUE
  116 NEND = N-2
      IF(NEND .EQ. 0) GO TO 118
C
C     CALCULATE VIA DIFFERENCE EQUATION AND STORE B(N),
C     UNTIL N=2
C
      DO 117 L=1,NEND
      N = N - 1
      B(N) = ((FLOAT(2*N))*B(N+1))/X-SIGN*B(N+2)
      M = 2-M
      SUM = SUM+(FLOAT(M))*B(N)
  117 CONTINUE
C
C     CALCULATE B(1)
C
  118 B(1) = 2.E0*B(2)/X-SIGN*B(3)
  119 SUM = SUM+B(1)
C
C     NORMALIZE--IF IZE=1, DIVIDE SUM BY COSH(X).  DIVIDE ALL
C     B(N) BY SUM.
C
  120 IF(IZE .EQ. 0) GO TO 121
      TEMPA = EXP(ABS(X))
      SUM = 2.E0*SUM/(TEMPA+1.E0/TEMPA)
  121 DO 122 N=1,NB
      B(N) = B(N)/SUM
  122 CONTINUE
      RETURN
C
C     TWO-TERM ASCENDING SERIES FOR SMALL X
C
  123 TEMPA = 1.E0
      TEMPB = -.25E0*X*X*SIGN
      B(1) = 1.E0+TEMPB
      IF(NB .EQ. 1) GO TO 125
      DO 124 N=2,NB
      TEMPA = TEMPA*X/(FLOAT(2*N-2))
      B(N) = TEMPA*(1.E0+TEMPB/(FLOAT(N)))
  124 CONTINUE
  125 RETURN
      END
      SUBROUTINE MIEPHAZE(ILAYER)
      PARAMETER (NUMCOEFS=256,NUMDPTS=160,NUMG=64,NUMLAYERS=32)
      PARAMETER (PI=3.14159265358979)
      CHARACTER TITLE*132,FN*255,PCTSIGN*3
      CHARACTER HEADER*80
      DIMENSION A(NUMLAYERS),B(NUMLAYERS),AMU1(NUMLAYERS),
     .AMU2(NUMLAYERS)
      COMMON/COM/TITLE,P(271),MAXM,LFILE,NPRNT,WOTRU,FN,CALCI(NUMDPTS),
     .G1,G2,F1,FGAS,A,B,WM,AMU1,AMU2,WAVL,EXTCRS
      WRITE(HEADER,5040) WAVL,A(ILAYER),B(ILAYER),
     .AMU1(ILAYER),AMU2(ILAYER)
5040  format('LAMBDA = ',F6.3,'  A = ',F6.3,'  B = ',F6.3,
     .' AMU1 = ',F5.3,' AMU2 = ',F5.3)
      RAD=180.0/PI
      DO 1 I=1,271
      THETA=(MIN(I-1,100)*0.1 + MAX(I-101,0)*1.0)*RAD
      XR=0.75*(1.0+COS(THETA)**2)
    1 P(I) = FGAS*XR + (1.-FGAS)*P(I)
      RETURN
      END
      SUBROUTINE MIESCAT(A,B,AMU1,AMU2,LAMBDA,NMIEPTS,P,KSCA,KABS,
     &KEXT,W,ASYM)
C
C     Scalar Mie scattering with Gaussian integration of the size
C     distribution.  This version does not support polarization or
C     non-spherical particles (via Pollack & Cuzzi).  It integrates
C     the size distribution with NMIEPTS Gaussian quadrature, which
C     in tests done so far requires about 1/3 to 1/2 the number of
C     integration points of Simpson's rule to reach the same accuracy.
C
      DIMENSION F11(271),SMF11(271),P(271)
      DIMENSION GMU1(512),GW1(512),GMU2(512),GW2(512)
      REAL LAMBDA
      REAL K,KSCA,KEXT,KABS

      PI = 3.14159265358979
      RADIAN = PI/180.0
      TWOPI = 2.0*PI

      XINT = 0.0

      K = TWOPI/LAMBDA

      WRITE(3,11) LAMBDA,A,B,AMU1,AMU2
   11 FORMAT(1X,'Mie scattering run for: ',/,
     .' LAMBDA = ',G13.6,'  A = ',G13.6,'  B = ',G13.6,/,
     .' AMU1 = ',G13.6,'  AMU2 = ',G13.6)
      XNSUM = 0.0
      KSCA = 0.0
      KEXT = 0.0

      DO 15 I=1,271
   15 P(I) = 0.0

      N = NMIEPTS
      CALL SIZPARMH(A,B,LAMBDA,XMIN,XMAX,XMID)
      RMIN=XMIN/K
      RMAX=XMAX/K
      RMID=XMID/K

      CALL GAULEG(RMID-2.*(RMID-RMIN),RMID,GMU1,GW1,N)
      CALL GAULEG(RMID,RMID+2.*(RMAX-RMID),GMU2,GW2,N)

      NN = N

      WRITE(3,20)
   20 FORMAT(///)

      WRITE(3,21)
   21 FORMAT(5X,1HR,10X,1HX,8X,4HQEXT,8X,4HQSCA,8X,4HQABS,8X,6HALBEDO,
     14X,3HXNR,7X,4HTEMP,8X,3HEXT,8X,3HSCA,8X,4HXINT)

      SMXNR = 0.0

      DO 25 I=1,271
   25 SMF11(I) = 0.0

      SMSCA = 0.0

      SMEXT = 0.0
      N2=(NN+1)/2

      IF(A.EQ.0.) CALL SIZINIT
      DO 100 I=1,NN
      INDEX=N2+I
      IF(INDEX.LE.NN) THEN
        R=GMU1(INDEX)
        GW=GW1(INDEX)
      ELSE
        R=GMU2(INDEX-NN)
        GW=GW2(INDEX-NN)
      ENDIF
      XNR = SIZDIS(R,A,B)

      X = R*K

      CALL MIEHISS(X,AMU1,AMU2,F11,QEXT,QSCA,QABS,ALBED,0)

      DO 30 J=1,271
   30 F11(J) = F11(J)*XNR

      TEMP = PI*R*R*XNR

      SCA = TEMP*QSCA

      EXT = TEMP*QEXT

      XINT = XINT + GW*EXT
      WRITE(3,35) R,X,QEXT,QSCA,QABS,ALBED,XNR,TEMP,EXT,SCA,XINT
   35 FORMAT(1P2E11.3,3E12.5,0PF9.6,1P4E11.3,E12.4)

C     GAUSSIAN INTEGRATION OVER SIZE DISTRIBUTION.

      SMXNR = SMXNR + GW*XNR
      SMSCA = SMSCA + GW*SCA
      SMEXT = SMEXT + GW*EXT

      DO 100 J=1,271
  100 P(J) = P(J) + GW*F11(J)

      XNSUM=SMXNR
      KSCA=SMSCA
      KEXT=SMEXT
      WRITE(3,111) XNSUM
  111 FORMAT(1H1,58X,6HN(R) =,E13.6,//)

      KSCA = KSCA/XNSUM

      WRITE(3,113) KSCA
  113 FORMAT(57X,8HK(SCA) =,E13.6,//)

      KEXT = KEXT/XNSUM

      WRITE(3,114) KEXT
  114 FORMAT(57X,8HK(EXT) =,E13.6,//)

      W = KSCA/KEXT

      WRITE(3,115) W
  115 FORMAT(62X,3HW =,E13.6,//)

      KABS=KEXT-KSCA
      C = (4.0*PI)/(K*K*KSCA*XNSUM)

      DO 120 I=1,271
  120 P(I) = C*P(I)

      WRITE(3,20)

      WRITE(3,121)
  121 FORMAT(3X,5HTHETA,9X,1HP,10X,5HLOG P)
      DO 123 I=1,271
      P11L = 0
      IF(P(I).NE.0) P11L = LOG10(P(I))
      THETA=MIN(I-1,100)*0.1 + MAX(I-101,0)*1.0
      WRITE(3,122) THETA,P(I),P11L
  122 FORMAT(2X,F6.2,1P2E13.3)
  123 CONTINUE

      SUM1P = 0.0
      SUM2P = 0.0
      SUM3P = 0.0

      TEST1 = 0.0
      TEST2 = 0.0
      TEST3 = 0.0

      DO 150 I=1,101

      THETA=MIN(I-1,100)*0.1 + MAX(I-101,0)*1.0
      TEST = P(I)*SIN(THETA*RADIAN)
      TEMP = P(I)*SIN(THETA*RADIAN)*COS(THETA*RADIAN)

      IF(I .NE. 1 .OR. I .NE. 101) GO TO 130
      SUM1P = SUM1P + TEMP
      TEST1 = TEST1 + TEST
      GO TO 150

  130 IF(I .NE. I/2*2) GO TO 140
      SUM2P = SUM2P + 4.0*TEMP
      TEST2 = TEST2 + 4.0*TEST
      GO TO 150

  140 SUM3P = SUM3P + 2.0*TEMP
      TEST3 = TEST3 + 2.0*TEST
  150 CONTINUE

      DELTA = 0.1*RADIAN
      G = DELTA/3.0*(SUM1P + SUM2P + SUM3P)
      GTEST = DELTA/3.0*(TEST1 + TEST2 + TEST3)

      SUM1P = 0.0
      SUM2P = 0.0
      SUM3P = 0.0

      TEST1 = 0.0
      TEST2 = 0.0
      TEST3 = 0.0

      DO 180 I=102,271

      THETA=MIN(I-1,100)*0.1 + MAX(I-101,0)*1.0
      TEST = P(I)*SIN(THETA*RADIAN)
      TEMP = P(I)*SIN(THETA*RADIAN)*COS(THETA*RADIAN)

      IF(I .NE. 102 .OR. I .NE. 271) GO TO 160
      SUM1P = SUM1P + TEMP
      TEST1 = TEST1 + TEST
      GO TO 180

  160 IF(I .NE. I/2*2) GO TO 170
      SUM2P = SUM2P + 4.0*TEMP
      TEST2 = TEST2 + 4.0*TEST
      GO TO 180

  170 SUM3P = SUM3P + 2.0*TEMP
      TEST3 = TEST3 + 2.0*TEST

  180 CONTINUE

      DELTA = 1.0*RADIAN
      G = 0.5*(G + DELTA/3.0*(SUM1P + SUM2P + SUM3P))

      WRITE(3,20)
      WRITE(3,181) G
  181 FORMAT(62X,3HG =,E13.6,//)

      ASYM=G

      GTEST = 0.5*(GTEST + DELTA/3.0*(TEST1 + TEST2 + TEST3))

      WRITE(3,182) GTEST
  182 FORMAT(58X,7HGTEST =,E13.6)

      END
      SUBROUTINE SIZPARMH(A,B,LAMBDA,XMIN,XMAX,XMID)
C     THIS SUBROUTINE COMPUTES RMIN AND RMAX FOR A STANDARD HANSEN
C     (GAMMA) DISTRIBUTION.
C
C     THESE STATEMENT FUNCTIONS EVALUATE LOG(N(R)*R**2) AND ITS
C     DERIVATIVE:
      REAL LOGE,LAMBDA
      DATA LOGE/0.4342945/,E/2.7182818/,PI/3.14159265358979/
      F(A,B,R)=(1.-B)/B*LOG10(R*E/A/(1.-B)) - R/A/B*LOGE
      FP(A,B,R)=LOGE/B*((1.-B)/R - 1./A)

      IF(A.EQ.0) THEN
        CALL SIZLIMG(RMIN,RMAX,RMID)
        XMIN=2.*PI*RMIN/LAMBDA
        XMAX=2.*PI*RMAX/LAMBDA
        XMID=2.*PI*RMID/LAMBDA
        RETURN
      ENDIF

C     COMPUTE RADIUS FOR WHICH SIZE DISTRIBUTION * R**2 IS MAXIMUM
C     AND SIZE DISTRIBUTION VALUE AT MAXIMUM.

      R0=A*(1.-B)
      RMAX=R0
      D=-4

C     GUESS MINIMUM R VALUE NEEDED.

      R1=10.D0**(LOG10(RMAX)-1.D0)

C     ITERATE NEWTON'S METHOD SOLUTION FOR RMIN.

   10 R2=R1-(F(A,B,R1)-D)/FP(A,B,R1)
      IF(ABS((R2-R1)/R1).GT.1.0D-3) THEN
      R1=MAX(R2,1.0D-10)
      GO TO 10
      ENDIF
      RMIN=R2

C     GUESS MAXIMUM R VALUE NEEDED.

      R1=10.**(LOG10(RMAX)+0.5)

C     ITERATE NEWTON'S METHOD SOLUTION FOR RMAX.

   20 R2=R1-(F(A,B,R1)-D)/FP(A,B,R1)
      IF(ABS((R2-R1)/R1).GT.1.0E-3) THEN
        R1=R2
        GO TO 20
      ENDIF
      RMAX=R2

      WRITE(6,5041) RMIN,RMAX
5041  format(' INTEGRATION LIMITS:  RMIN = ',G13.6,' RMAX = ',G13.6)
      XMIN=2.*PI*RMIN/LAMBDA
      XMAX=2.*PI*RMAX/LAMBDA
      XMID=2.*PI*R0/LAMBDA

      RETURN
      END
      SUBROUTINE CURV1 (N,X,Y,SLP1,SLPN,ISLPSW,YP,TEMP,
     *                  SIGMA,IERR)
C
      INTEGER N,ISLPSW,IERR
      REAL X(N),Y(N),SLP1,SLPN,YP(N),TEMP(N),SIGMA
C
C                      FROM THE SPLINE UNDER TENSION PACKAGE
C                       CODED BY A. K. CLINE AND R. J. RENKA
C                            DEPARTMENT OF COMPUTER SCIENCES
C                              UNIVERSITY OF TEXAS AT AUSTIN
C
C THIS SUBROUTINE DETERMINES THE PARAMETERS NECESSARY TO
C COMPUTE AN INTERPOLATORY SPLINE UNDER TENSION THROUGH
C A SEQUENCE OF FUNCTIONAL VALUES. THE SLOPES AT THE TWO
C ENDS OF THE CURVE MAY BE SPECIFIED OR OMITTED.  FOR ACTUAL
C COMPUTATION OF POINTS ON THE CURVE IT IS NECESSARY TO CALL
C THE FUNCTION CURV2.
C
C ON INPUT--
C
C   N IS THE NUMBER OF VALUES TO BE INTERPOLATED (N.GE.2).
C
C   X IS AN ARRAY OF THE N INCREASING ABSCISSAE OF THE
C   FUNCTIONAL VALUES.
C
C   Y IS AN ARRAY OF THE N ORDINATES OF THE VALUES, (I. E.
C   Y(K) IS THE FUNCTIONAL VALUE CORRESPONDING TO X(K) ).
C
C   SLP1 AND SLPN CONTAIN THE DESIRED VALUES FOR THE FIRST
C   DERIVATIVE OF THE CURVE AT X(1) AND X(N), RESPECTIVELY.
C   THE USER MAY OMIT VALUES FOR EITHER OR BOTH OF THESE
C   PARAMETERS AND SIGNAL THIS WITH ISLPSW.
C
C   ISLPSW CONTAINS A SWITCH INDICATING WHICH SLOPE DATA
C   SHOULD BE USED AND WHICH SHOULD BE ESTIMATED BY THIS
C   SUBROUTINE,
C          = 0 IF SLP1 AND SLPN ARE TO BE USED,
C          = 1 IF SLP1 IS TO BE USED BUT NOT SLPN,
C          = 2 IF SLPN IS TO BE USED BUT NOT SLP1,
C          = 3 IF BOTH SLP1 AND SLPN ARE TO BE ESTIMATED
C              INTERNALLY.
C
C   YP IS AN ARRAY OF LENGTH AT LEAST N.
C
C   TEMP IS AN ARRAY OF LENGTH AT LEAST N WHICH IS USED FOR
C   SCRATCH STORAGE.
C
C AND
C
C   SIGMA CONTAINS THE TENSION FACTOR. THIS VALUE INDICATES
C   THE CURVINESS DESIRED. IF ABS(SIGMA) IS NEARLY ZERO
C   (E.G. .001) THE RESULTING CURVE IS APPROXIMATELY A
C   CUBIC SPLINE. IF ABS(SIGMA) IS LARGE (E.G. 50.) THE
C   RESULTING CURVE IS NEARLY A POLYGONAL LINE. IF SIGMA
C   EQUALS ZERO A CUBIC SPLINE RESULTS.  A STANDARD VALUE
C   FOR SIGMA IS APPROXIMATELY 1. IN ABSOLUTE VALUE.
C
C ON OUTPUT--
C
C   YP CONTAINS THE VALUES OF THE SECOND DERIVATIVE OF THE
C   CURVE AT THE GIVEN NODES.
C
C   IERR CONTAINS AN ERROR FLAG,
C        = 0 FOR NORMAL RETURN,
C        = 1 IF N IS LESS THAN 2,
C        = 2 IF X-VALUES ARE NOT STRICTLY INCREASING.
C
C AND
C
C   N, X, Y, SLP1, SLPN, ISLPSW AND SIGMA ARE UNALTERED.
C
C THIS SUBROUTINE REFERENCES PACKAGE MODULES CEEZ, TERMS,
C AND SNHCSH.
C
C-----------------------------------------------------------
C
      NM1 = N-1
      NP1 = N+1
      IERR = 0
      IF (N .LE. 1) GO TO 8
      IF (X(N) .LE. X(1)) GO TO 9
C
C DENORMALIZE TENSION FACTOR
C
      SIGMAP = ABS(SIGMA)*FLOAT(N-1)/(X(N)-X(1))
C
C APPROXIMATE END SLOPES
C
      IF (ISLPSW .GE. 2) GO TO 1
      SLPP1 = SLP1
      GO TO 2
    1 DELX1 = X(2)-X(1)
      DELX2 = DELX1+DELX1
      IF (N .GT. 2) DELX2 = X(3)-X(1)
      IF (DELX1 .LE. 0. .OR. DELX2 .LE. DELX1) GO TO 9
      CALL CEEZ (DELX1,DELX2,SIGMAP,C1,C2,C3,N)
      SLPP1 = C1*Y(1)+C2*Y(2)
      IF (N .GT. 2) SLPP1 = SLPP1+C3*Y(3)
    2 IF (ISLPSW .EQ. 1 .OR. ISLPSW .EQ. 3) GO TO 3
      SLPPN = SLPN
      GO TO 4
    3 DELXN = X(N)-X(NM1)
      DELXNM = DELXN+DELXN
      IF (N .GT. 2) DELXNM = X(N)-X(N-2)
      IF (DELXN .LE. 0. .OR. DELXNM .LE. DELXN) GO TO 9
      CALL CEEZ (-DELXN,-DELXNM,SIGMAP,C1,C2,C3,N)
      SLPPN = C1*Y(N)+C2*Y(NM1)
      IF (N .GT. 2) SLPPN = SLPPN+C3*Y(N-2)
C
C SET UP RIGHT HAND SIDE AND TRIDIAGONAL SYSTEM FOR YP AND
C PERFORM FORWARD ELIMINATION
C
    4 DELX1 = X(2)-X(1)
      IF (DELX1 .LE. 0.) GO TO 9
      DX1 = (Y(2)-Y(1))/DELX1
      CALL TERMS (DIAG1,SDIAG1,SIGMAP,DELX1)
      YP(1) = (DX1-SLPP1)/DIAG1
      TEMP(1) = SDIAG1/DIAG1
      IF (N .EQ. 2) GO TO 6
      DO 5 I = 2,NM1
        DELX2 = X(I+1)-X(I)
        IF (DELX2 .LE. 0.) GO TO 9
        DX2 = (Y(I+1)-Y(I))/DELX2
        CALL TERMS (DIAG2,SDIAG2,SIGMAP,DELX2)
        DIAG = DIAG1+DIAG2-SDIAG1*TEMP(I-1)
        YP(I) = (DX2-DX1-SDIAG1*YP(I-1))/DIAG
        TEMP(I) = SDIAG2/DIAG
        DX1 = DX2
        DIAG1 = DIAG2
    5   SDIAG1 = SDIAG2
    6 DIAG = DIAG1-SDIAG1*TEMP(NM1)
      YP(N) = (SLPPN-DX1-SDIAG1*YP(NM1))/DIAG
C
C PERFORM BACK SUBSTITUTION
C
      DO 7 I = 2,N
        IBAK = NP1-I
    7   YP(IBAK) = YP(IBAK)-TEMP(IBAK)*YP(IBAK+1)
      RETURN
C
C TOO FEW POINTS
C
    8 IERR = 1
      RETURN
C
C X-VALUES NOT STRICTLY INCREASING
C
    9 IERR = 2
      RETURN
      END
**CURV2
      FUNCTION CURV2 (T,N,X,Y,YP,SIGMA)
C
      INTEGER N
      REAL T,X(N),Y(N),YP(N),SIGMA
C
C                      FROM THE SPLINE UNDER TENSION PACKAGE
C                       CODED BY A. K. CLINE AND R. J. RENKA
C                            DEPARTMENT OF COMPUTER SCIENCES
C                              UNIVERSITY OF TEXAS AT AUSTIN
C
C THIS FUNCTION INTERPOLATES A CURVE AT A GIVEN POINT
C USING A SPLINE UNDER TENSION. THE SUBROUTINE CURV1 SHOULD
C BE CALLED EARLIER TO DETERMINE CERTAIN NECESSARY
C PARAMETERS.
C
C ON INPUT--
C
C   T CONTAINS A REAL VALUE TO BE MAPPED ONTO THE INTERPO-
C   LATING CURVE.
C
C   N CONTAINS THE NUMBER OF POINTS WHICH WERE SPECIFIED TO
C   DETERMINE THE CURVE.
C
C   X AND Y ARE ARRAYS CONTAINING THE ABSCISSAE AND
C   ORDINATES, RESPECTIVELY, OF THE SPECIFIED POINTS.
C
C   YP IS AN ARRAY OF SECOND DERIVATIVE VALUES OF THE CURVE
C   AT THE NODES.
C
C AND
C
C   SIGMA CONTAINS THE TENSION FACTOR (ITS SIGN IS IGNORED).
C
C THE PARAMETERS N, X, Y, YP, AND SIGMA SHOULD BE INPUT
C UNALTERED FROM THE OUTPUT OF CURV1.
C
C ON OUTPUT--
C
C   CURV2 CONTAINS THE INTERPOLATED VALUE.
C
C NONE OF THE INPUT PARAMETERS ARE ALTERED.
C
C THIS FUNCTION REFERENCES PACKAGE MODULES INTRVL AND
C SNHCSH.
C
C-----------------------------------------------------------
C
C DETERMINE INTERVAL
C
      IM1 = INTRVL(T,X,N)
      I = IM1+1
C
C DENORMALIZE TENSION FACTOR
C
      SIGMAP = ABS(SIGMA)*FLOAT(N-1)/(X(N)-X(1))
C
C SET UP AND PERFORM INTERPOLATION
C
      DEL1 = T-X(IM1)
      DEL2 = X(I)-T
      DELS = X(I)-X(IM1)
      SUM = (Y(I)*DEL1+Y(IM1)*DEL2)/DELS
      IF (SIGMAP .NE. 0.) GO TO 1
      CURV2 = SUM-DEL1*DEL2*(YP(I)*(DEL1+DELS)+YP(IM1)*
     *        (DEL2+DELS))/(6.*DELS)
      RETURN
    1 DELP1 = SIGMAP*(DEL1+DELS)/2.
      DELP2 = SIGMAP*(DEL2+DELS)/2.
      CALL SNHCSH (SINHM1,DUMMY,SIGMAP*DEL1,-1)
      CALL SNHCSH (SINHM2,DUMMY,SIGMAP*DEL2,-1)
      CALL SNHCSH (SINHMS,DUMMY,SIGMAP*DELS,-1)
      CALL SNHCSH (SINHP1,DUMMY,SIGMAP*DEL1/2.,-1)
      CALL SNHCSH (SINHP2,DUMMY,SIGMAP*DEL2/2.,-1)
      CALL SNHCSH (DUMMY,COSHP1,DELP1,1)
      CALL SNHCSH (DUMMY,COSHP2,DELP2,1)
      CURV2 = SUM+(YP(I)*(SINHM1*DEL2-DEL1*(2.*(COSHP1+1.)*
     *        SINHP2+SIGMAP*COSHP1*DEL2))+YP(IM1)*(SINHM2*
     *        DEL1-DEL2*(2.*(COSHP2+1.)*SINHP1+SIGMAP*
     *        COSHP2*DEL1)))/(SIGMAP*SIGMAP*DELS*(SINHMS+
     *        SIGMAP*DELS))
      RETURN
      END
**CEEZ
      SUBROUTINE CEEZ (DEL1,DEL2,SIGMA,C1,C2,C3,N)
C
      REAL DEL1,DEL2,SIGMA,C1,C2,C3
C
C                      FROM THE SPLINE UNDER TENSION PACKAGE
C                       CODED BY A. K. CLINE AND R. J. RENKA
C                            DEPARTMENT OF COMPUTER SCIENCES
C                              UNIVERSITY OF TEXAS AT AUSTIN
C
C THIS SUBROUTINE DETERMINES THE COEFFICIENTS C1, C2, AND C3
C USED TO DETERMINE ENDPOINT SLOPES. SPECIFICALLY, IF
C FUNCTION VALUES Y1, Y2, AND Y3 ARE GIVEN AT POINTS X1, X2,
C AND X3, RESPECTIVELY, THE QUANTITY C1*Y1 + C2*Y2 + C3*Y3
C IS THE VALUE OF THE DERIVATIVE AT X1 OF A SPLINE UNDER
C TENSION (WITH TENSION FACTOR SIGMA) PASSING THROUGH THE
C THREE POINTS AND HAVING THIRD DERIVATIVE EQUAL TO ZERO AT
C X1. OPTIONALLY, ONLY TWO VALUES, C1 AND C2 ARE DETERMINED.
C
C ON INPUT--
C
C   DEL1 IS X2-X1 (.GT. 0.).
C
C   DEL2 IS X3-X1 (.GT. 0.). IF N .EQ. 2, THIS PARAMETER IS
C   IGNORED.
C
C   SIGMA IS THE TENSION FACTOR.
C
C AND
C
C   N IS A SWITCH INDICATING THE NUMBER OF COEFFICIENTS TO
C   BE RETURNED. IF N .EQ. 2 ONLY TWO COEFFICIENTS ARE
C   RETURNED. OTHERWISE ALL THREE ARE RETURNED.
C
C ON OUTPUT--
C
C   C1, C2, AND C3 CONTAIN THE COEFFICIENTS.
C
C NONE OF THE INPUT PARAMETERS ARE ALTERED.
C
C THIS SUBROUTINE REFERENCES PACKAGE MODULE SNHCSH.
C
C-----------------------------------------------------------
C
      IF (N .EQ. 2) GO TO 2
      IF (SIGMA .NE. 0.) GO TO 1
      DEL = DEL2-DEL1
C
C TENSION .EQ. 0.
C
      C1 = -(DEL1+DEL2)/(DEL1*DEL2)
      C2 = DEL2/(DEL1*DEL)
      C3 = -DEL1/(DEL2*DEL)
      RETURN
C
C TENSION .NE. 0.
C
    1 CALL SNHCSH (DUMMY,COSHM1,SIGMA*DEL1,1)
      CALL SNHCSH (DUMMY,COSHM2,SIGMA*DEL2,1)
      DELP = SIGMA*(DEL2+DEL1)/2.
      DELM = SIGMA*(DEL2-DEL1)/2.
      CALL SNHCSH (SINHMP,DUMMY,DELP,-1)
      CALL SNHCSH (SINHMM,DUMMY,DELM,-1)
      DENOM = COSHM1*(DEL2-DEL1)-2.*DEL1*(SINHMP+DELP)*
     *        (SINHMM+DELM)
      C1 = 2.*(SINHMP+DELP)*(SINHMM+DELM)/DENOM
      C2 = -COSHM2/DENOM
      C3 = COSHM1/DENOM
      RETURN
C
C TWO COEFFICIENTS
C
    2 C1 = -1./DEL1
      C2 = -C1
      RETURN
      END
**TERMS
      SUBROUTINE TERMS (DIAG,SDIAG,SIGMA,DEL)
C
      REAL DIAG,SDIAG,SIGMA,DEL
C
C                      FROM THE SPLINE UNDER TENSION PACKAGE
C                       CODED BY A. K. CLINE AND R. J. RENKA
C                            DEPARTMENT OF COMPUTER SCIENCES
C                              UNIVERSITY OF TEXAS AT AUSTIN
C
C THIS SUBROUTINE COMPUTES THE DIAGONAL AND SUPERDIAGONAL
C TERMS OF THE TRIDIAGONAL LINEAR SYSTEM ASSOCIATED WITH
C SPLINE UNDER TENSION INTERPOLATION.
C
C ON INPUT--
C
C   SIGMA CONTAINS THE TENSION FACTOR.
C
C AND
C
C   DEL CONTAINS THE STEP SIZE.
C
C ON OUTPUT--
C
C               (SIGMA*DEL*COSH(SIGMA*DEL) - SINH(SIGMA*DEL)
C   DIAG = DEL*--------------------------------------------.
C                     (SIGMA*DEL)**2 * SINH(SIGMA*DEL)
C
C                   SINH(SIGMA*DEL) - SIGMA*DEL
C   SDIAG = DEL*----------------------------------.
C                (SIGMA*DEL)**2 * SINH(SIGMA*DEL)
C
C AND
C
C   SIGMA AND DEL ARE UNALTERED.
C
C THIS SUBROUTINE REFERENCES PACKAGE MODULE SNHCSH.
C
C-----------------------------------------------------------
C
      IF (SIGMA .NE. 0.) GO TO 1
      DIAG = DEL/3.
      SDIAG = DEL/6.
      RETURN
    1 SIGDEL = SIGMA*DEL
      CALL SNHCSH (SINHM,COSHM,SIGDEL,0)
      DENOM = DEL/((SINHM+SIGDEL)*SIGDEL*SIGDEL)
      DIAG = DENOM*(SIGDEL*COSHM-SINHM)
      SDIAG = DENOM*SINHM
      RETURN
      END
**SNHCSH
      SUBROUTINE SNHCSH (SINHM,COSHM,X,ISW)
C
      INTEGER ISW
      REAL SINHM,COSHM,X
C
C                      FROM THE SPLINE UNDER TENSION PACKAGE
C                       CODED BY A. K. CLINE AND R. J. RENKA
C                            DEPARTMENT OF COMPUTER SCIENCES
C                              UNIVERSITY OF TEXAS AT AUSTIN
C
C THIS SUBROUTINE RETURNS APPROXIMATIONS TO
C       SINHM(X) = SINH(X)-X
C       COSHM(X) = COSH(X)-1
C AND
C       COSHMM(X) = COSH(X)-1-X*X/2
C WITH RELATIVE ERROR LESS THAN 3.42E-14
C
C ON INPUT--
C
C   X CONTAINS THE VALUE OF THE INDEPENDENT VARIABLE.
C
C   ISW INDICATES THE FUNCTION DESIRED
C           = -1 IF ONLY SINHM IS DESIRED,
C           =  0 IF BOTH SINHM AND COSHM ARE DESIRED,
C           =  1 IF ONLY COSHM IS DESIRED,
C           =  2 IF ONLY COSHMM IS DESIRED,
C           =  3 IF BOTH SINHM AND COSHMM ARE DESIRED.
C
C ON OUTPUT--
C
C   SINHM CONTAINS THE VALUE OF SINHM(X) IF ISW .LE. 0 OR
C   ISW .EQ. 3 (SINHM IS UNALTERED IF ISW .EQ.1 OR ISW .EQ.
C   2).
C
C   COSHM CONTAINS THE VALUE OF COSHM(X) IF ISW .EQ. 0 OR
C   ISW .EQ. 1 AND CONTAINS THE VALUE OF COSHMM(X) IF ISW
C   .GE. 2 (COSHM IS UNALTERED IF ISW .EQ. -1).
C
C AND
C
C   X AND ISW ARE UNALTERED.
C
C-----------------------------------------------------------
C
      DATA SP4/4.50217693381333E-08/,
     *     SP3/8.95278544216390E-06/,
     *     SP2/8.72048976791502E-04/,
     *     SP1/4.36314556981690E-02/,
     *     SQ1/-6.36854430175110E-03/
      DATA CP4/1.78419567490190E-07/,
     *     CP3/2.87277229799044E-05/,
     *     CP2/2.15151519902028E-03/,
     *     CP1/7.58181822756256E-02/,
     *     CQ1/-7.51515105679867E-03/
      DATA ZP3/5.59297116264720E-07/,
     *     ZP2/1.77943488030894E-04/,
     *     ZP1/1.69800461894792E-02/,
     *     ZQ4/1.33412535492375E-09/,
     *     ZQ3/-5.80858944138663E-07/,
     *     ZQ2/1.27814964403863E-04/,
     *     ZQ1/-1.63532871439181E-02/
      XX = X
      AX = ABS(XX)
      XS = XX*XX
      IF ((AX .GE. 2.70) .OR. (AX .GE. 1.15 .AND.
     *     ISW .NE. 2)) EXPX = EXP(AX)
C
C SINHM APPROXIMATION
C
      IF (ISW .EQ. 1 .OR. ISW .EQ. 2) GO TO 2
      IF (AX .GE. 1.15) GO TO 1
      SINHM = (((((SP4*XS+SP3)*XS+SP2)*XS+SP1)*XS+1.)*XS*XX)
     *        /((SQ1*XS+1.)*6.)
      GO TO 2
    1 SINHM = -(((1./EXPX+AX)+AX)-EXPX)/2.
      IF (XX .LT. 0.) SINHM = -SINHM
C
C COSHM APPROXIMATION
C
    2 IF (ISW .NE. 0 .AND. ISW .NE. 1) GO TO 4
      IF (AX .GE. 1.15) GO TO 3
      COSHM = (((((CP4*XS+CP3)*XS+CP2)*XS+CP1)*XS+1.)*XS)
     *        /((CQ1*XS+1.)*2.)
      GO TO 4
    3 COSHM = ((1./EXPX-2.)+EXPX)/2.
C
C COSHMM APPROXIMATION
C
    4 IF (ISW .LE. 1) RETURN
      IF (AX .GE. 2.70) GO TO 5
      COSHM = ((((ZP3*XS+ZP2)*XS+ZP1)*XS+1.)*XS*XS)/(((((ZQ4
     *        *XS+ZQ3)*XS+ZQ2)*XS+ZQ1)*XS+1.)*24.)
      RETURN
    5 COSHM = (((1./EXPX-2.)-XS)+EXPX)/2.
      RETURN
      END
**INTRVL
      integer FUNCTION INTRVL (T,X,N)
C
      INTEGER N
      REAL T,X(N)
C
C                      FROM THE SPLINE UNDER TENSION PACKAGE
C                       CODED BY A. K. CLINE AND R. J. RENKA
C                            DEPARTMENT OF COMPUTER SCIENCES
C                              UNIVERSITY OF TEXAS AT AUSTIN
C
C THIS FUNCTION DETERMINES THE INDEX OF THE INTERVAL
C (DETERMINED BY A GIVEN INCREASING SEQUENCE) IN WHICH
C A GIVEN VALUE LIES.
C
C ON INPUT--
C
C   T IS THE GIVEN VALUE.
C
C   X IS A VECTOR OF STRICTLY INCREASING VALUES.
C
C AND
C
C   N IS THE LENGTH OF X (N .GE. 2).
C
C ON OUTPUT--
C
C   INTRVL RETURNS AN INTEGER I SUCH THAT
C
C          I = 1       IF             T .LE. X(2)  ,
C          I = N-1     IF X(N-1) .LE. T            ,
C          OTHERWISE       X(I)  .LE. T .LE. X(I+1),
C
C NONE OF THE INPUT PARAMETERS ARE ALTERED.
C
C-----------------------------------------------------------
C
      TT = T
      IF (TT .LE. X(2)) GO TO 4
      IF (TT .GE. X(N-1)) GO TO 5
      IL = 2
      IH = N-1
C
C LINEAR INTERPOLATION
C
    1 I = IL+INT(FLOAT(IH-IL)*(TT-X(IL))/(X(IH)-X(IL)))
      IF (TT .LT. X(I)) GO TO 2
      IF (TT .LE. X(I+1)) GO TO 3
C
C TOO HIGH
C
      IL = I+1
      GO TO 1
C
C TOO LOW
C
    2 IH = I
      GO TO 1
    3 INTRVL = I
      RETURN
C
C LEFT END
C
    4 INTRVL = 1
      RETURN
C
C RIGHT END
C
    5 INTRVL = N-1
      RETURN
      END
        SUBROUTINE LAGRN2(XARRAY,YARRAY,NPTS,X,FX)
        DIMENSION XARRAY(*),YARRAY(*)
        DIMENSION XT(4), FXT(4), P(4)
C
C  FOUR POINT LAGRANGIAN INTERPOLATION TO OBTAIN FX, GIVEN XARRAY AND
C  YARRAY, AT X.
C
C       SELECT 4 POINTS SURROUNDING REQUIRED VALUE X.
C
        MPTS=NPTS-2
        DO 40 I=3,MPTS
        IF(XARRAY(I).GT.X) GO TO 50
40      CONTINUE
        I=MPTS+1
50      I1=I-2
        DO 60 I=1,4
        XT(I)=XARRAY(I1+I-1)
60      FXT(I)=YARRAY(I1+I-1)
        DO 1 I=1,4
        IF(X.EQ.XT(I)) GO TO 2
    1   CONTINUE
        GO TO 3
    2   FX=FXT(I)
        RETURN
C
C  COMPUTE DENOMINATORS OF LAGRANGIAN COEFFICIENTS
C
    3   DO 5 I=1,4
        PROD = 1.00
        DO 4 J=1,4
        IF(I.EQ.J) GO TO 4
        PROD = PROD*(XT(I)-XT(J))
    4   CONTINUE
        P(I)=PROD
    5   CONTINUE
C
C  COMPUTE GENERAL NUMERATOR
C
        PROD=1.00
        DO 6 I=1,4
        PROD= PROD*(X-XT(I))
    6   CONTINUE
C
C  COMPUTE LAGRANGIAN COEFFICIENTS AND THE INTERPOLATED VALUE
C
        FX=0.00
        DO 7 I=1,4
        XL=PROD/(P(I)*(X-XT(I)))
        FX=FX + XL*FXT(I)
    7   CONTINUE
        RETURN
        END
      SUBROUTINE gauleg(x1,x2,x,w,n)
      INTEGER n
      REAL x1,x2,x(n),w(n)
      PARAMETER (EPS=3.e-14)
      INTEGER i,j,m
      m=(n+1)/2
      xm=0.50*(x2+x1)
      xl=0.50*(x2-x1)
      do 12 i=1,m
        z=cos(3.14159265358979*(i-.25)/(n+.5))
1       continue
          p1=1.0
          p2=0.d0
          do 11 j=1,n
            p3=p2
            p2=p1
            p1=((2.0*j-1.0)*z*p2-(j-1.0)*p3)/j
11        continue
          pp=n*(z*p1-p2)/(z*z-1.0)
          z1=z
          z=z1-p1/pp
        if(abs(z-z1).gt.EPS)goto 1
        x(i)=xm-xl*z
        x(n+1-i)=xm+xl*z
        w(i)=2.0*xl/((1.d0-z*z)*pp*pp)
        w(n+1-i)=w(i)
12    continue
      return
      END
      SUBROUTINE RENEW(FN)
      CHARACTER*(*) FN
      OPEN(19,FILE=FN,STATUS='UNKNOWN',IOSTAT=ios)
      IF(ios.eq.0) THEN
        CLOSE(19,STATUS='DELETE')
      ELSE
        WRITE(6,10) FN
10      FORMAT('Could not open ',A20)
        STOP
      ENDIF
      RETURN
      END
      SUBROUTINE LAMBERT(GR,TAUA)
      PARAMETER (NUMG=64)
      DIMENSION P(271),SO(NUMG,NUMG),SSO(NUMG,NUMG),T(NUMG,NUMG)
      REAL MU(NUMG),W(NUMG)
C     GAUSSIAN POINTS AND WEIGHTS FOR 0 TO 1 QUADRATURE
      COMMON/DA/IRECNO
     
      NUM=NUMG
      
      CALL GAULEG(0.0,1.0,MU,W,NUM)
      
      DO 10 I=1,271
        P(I)=1.0
   10 CONTINUE
      WRITE(10,REC=IRECNO) P
      write(13,1107) IRECNO
1107  format(I6,'  P(Lambert)')
      IRECNO=IRECNO+1
   
C     Generate the multiple and single scattering S functions for a
C     Lambert surface.
      DO 30 I = 1, NUM
        GR4MUI = GR*4.0*MU(I)
        DO 30 J = I,NUM
          SO(I,J) = MU(J)*GR4MUI
          SO(J,I) = SO(I,J)
          SSO(I,J) = SO(I,J)
          SSO(J,I) = SO(J,I)
          T(I,J) = 0.0
          T(J,I) = 0.0
   30 CONTINUE

      TAU=0.0D0
C     Save the function for this Fourier order (0) on disk for INTENSI4
      WRITE(10,REC=IRECNO) GR,TAU,SO,T,SSO,T
      write(13,1108) IRECNO
1108  format(I6,'  GR, TAU, SO, T, SSO, T for Lambert')
      IRECNO=IRECNO+1

      RETURN
      END
      SUBROUTINE HAPKE(W,NBOT,TAUA,HAPKE_B0,HAPKE_B,HAPKE_C,HAPKE_H)
      PARAMETER (NUMCOEFS=256,NUMDPTS=160,NUMG=64,NUMLAYERS=32)
      CHARACTER TITLE*132,FN*255
      DIMENSION A(NUMLAYERS),B(NUMLAYERS),AMU1(NUMLAYERS),
     &  AMU2(NUMLAYERS)
C     GAUSSIAN POINTS AND WEIGHTS FOR 0 TO 1 QUADRATURE
      COMMON/DA/IRECNO
      COMMON/COM/TITLE,P(271),MAXM,LFILE,NPRNT,WOTRU,FN,CALCI(NUMDPTS),
     .G1L,G2L,F1L,FGAS,A,B,WM,AMU1,AMU2,WAVL,SIGMA
      
C     Generate the Hapke single scattering phase function at the 271
C     scattering angles
      DO 10 I=1,271
        THETAD=MIN(I-1,100)*0.1 + MAX(I-101,0)*1.0
		THETA=THETAD/57.295779513084
        G=3.14159265358979-THETAD/57.295779513084
        P(I)=(1.0+HAPKE_B0/(1.0+TAN(G/2.0)/HAPKE_H))*
     &    ((1.0-HAPKE_C)*(1.0-HAPKE_B**2)/((1.0-2.0*HAPKE_B*COS(THETA)
     &    +HAPKE_B**2)**1.5) +
     &     HAPKE_C*(1.0-HAPKE_B**2)/((1.0+2.0*HAPKE_B*COS(THETA)
     &    +HAPKE_B**2)**1.5))
   10 CONTINUE
   
      WRITE(10,REC=IRECNO) P
      write(13,1109) IRECNO
1109  format(I6,' P(Hapke)')
      IRECNO=IRECNO+1
      
C     Do the Fourier decomposition of the Hapke function
      CALL DHAPKE(W)
      
      RETURN
      END
      SUBROUTINE DHAPKE(HAPKE_W)
C     This routine sets up the Fourier decomposition of the Hapke
C     surface function and writes the Fourier coefficients to the S
C     and T function file.
C     4/10/97 - LRD

      PARAMETER (NUMCOEFS=256,NUMG=64,NUMDPTS=160,NUMLAYERS=32)
      DIMENSION A(NUMLAYERS),B(NUMLAYERS),AMU1(NUMLAYERS),
     .AMU2(NUMLAYERS)
      COMMON/SUN1/ WALB
      CHARACTER TITLE*132,FN*255
      REAL LAMBDA
      REAL SS(NUMG,NUMG),TS(NUMG,NUMG)
      COMMON/COM/TITLE,P(271),MAXM,LFILE,NPRNT,WOTRU,FN,CALCI(NUMDPTS),
     .G1,G2,F1,FGAS,A,B,WM,AMU1,AMU2,LAMBDA,EXTCRS
      COMMON/DB/NUM,M,MQUIT,TAU,TSTRT,TLAST,XMU(NUMG),W(NUMG),
     .S(NUMG,NUMG),T(NUMG,NUMG)
     .,PSM(NUMCOEFS,NUMG,NUMG),PTM(NUMCOEFS,NUMG,NUMG)
     .,SB(NUMCOEFS,NUMG,NUMG)
     .,SALL(NUMCOEFS),TALL(NUMCOEFS)
      COMMON/DA/IRECNO
C
C     GAUSSIAN POINTS AND WEIGHTS FOR 0 TO 1 QUADRATURE.
C
      NUM = NUMG
      CALL GAULEG(0.0,1.0,XMU,W,NUM)
   
C
C     SET PARAMETERS AND INITIAL VALUES
C

      WRITE(3,5015)
 5015 FORMAT(1H0)

C     IN THIS PROGRAM M IS THE ORDER OF THE FOURIER COEFFICIENT PLUS ONE
C     LFILE IS THE FILE NUMBER OF THE LAST FILE ALREADY ON THE TAPE.
C     NPRNT = 0 STOPS outputING OF S(M) AND T(M) VALUES IN OUTPUT SECTION
C     GENERATE THE (MAXM) FOURIER ORDERS OF THE PHASE FUNCTION.
C     FIRST, INITIALIZE SUBROUTINE PHASD FOR SUBSEQUENT CALLS.
C
      NPRNT = 0
      CALL PHASD(F,G)

      DO 4 I=1,NUM
      ZMU = XMU(I)
      DO 4 J=I,NUM
      ZMUO = XMU(J)

      CALL HAPFOUR(MAXM,ZMU,ZMUO,HAPKE_W,SALL,TALL)

      DO 4 N=1,MAXM
      PSM(N,I,J) = SALL(N)
      PSM(N,J,I) = SALL(N)
    4 CONTINUE
      
      DO 5 I=1,NUM
        DO 5 J=1,NUM
          T(I,J)=0.0
          TS(I,J)=0.0
    5 CONTINUE
    
C     Write the S and T functions.  The T functions for the surface
C     are not used.
      TAU=0.0D0
      DO 7 N=1,MAXM
        DO 6 I=1,NUM
          DO 6 J=1,NUM
            S(I,J)=PSM(N,I,J)
            SS(I,J)=S(I,J)
    6   CONTINUE
        WRITE(10,REC=IRECNO) WOTRU,TAU,S,T,SS,TS
        write(13,1110) IRECNO
1110    format(I6,'  WOTRU, TAU, S, T, SS, TS for Hapke')
        IRECNO=IRECNO+1
    7 CONTINUE
      
      RETURN
      END
      SUBROUTINE HAPFOUR(NUMC,XMU,XMUO,W,S,T)
C     Computes NUMC Fourier coefficients for the representation of the
C     PHI-PHI(0) dependence of PS and PT by direct integration.
      PARAMETER (NUMCOEFS=256,NUMG=64,NUMDPTS=160,NUMLAYERS=32)
      PARAMETER (NO=512)
      DIMENSION THETA(271), XCOS(0:NO,NUMCOEFS)
      COMMON /SUN2/ THETA,XCOS
      DIMENSION S(NUMCOEFS), T(NUMCOEFS)
      CHARACTER TITLE*132,FN*255
      COMMON/COM/TITLE,P(271),MAXM,LFILE,NPRNT,WOTRU,FN,CALCI(NUMDPTS),
     .G1,G2,F1,FGAS,XDUM1(NUMLAYERS),XDUM2(NUMLAYERS),XDUM3,
     .XDUM4(NUMLAYERS),XDUM5(NUMLAYERS),XDUM6,XDUM7
      DATA PI/3.14159265358979/
      
      RAD=PI/180.0

C     Maximum number of points used to do integral
      NEVAL=512
      IFAC=1

      DO 10 M=1,NUMCOEFS
      S(M)=0.
10    T(M)=0.

C  Integrate over phi - phi0 using Simpson's rule with NEVAL intervals
C
      DPHI=PI/REAL(NEVAL)*IFAC
      MODTST=2*IFAC
      B=SQRT(1.-XMU**2)*SQRT(1.-XMUO**2)
      AT=XMU*XMUO
      AS=-AT
      
      DO 20 I=0,NEVAL,IFAC
C     Set the Simpson weight
      IF(MOD(I,MODTST).EQ.0) THEN
        WT=2.
      ELSE
        WT=4.
      ENDIF
      IF(I.EQ.0.OR.I.EQ.NEVAL) WT=1.
C
C  Compute the scattering angle
C
C     For reflection
C      THETAS=ACOS(AS+B*XCOS(I,1))
          OPERAND=AS+B*XCOS(I,1)
      if(OPERAND.LT.-1.0D0) OPERAND=-1.0D0
      if(OPERAND.GT.1.0D0) OPERAND=1.0D0
      THETAS=ACOS(OPERAND)
      THETASD=THETAS/RAD
C
C  Interpolate for the phase function at these angles
C
C  The following statement computes the number of the phase
C  function table entry which is just smaller than the scattering
C  angles.  They are valid for the standard 103 point phase function
C  scheme used at this writing.  They must be changed if another
C  scheme is used.
C
      N1S=INT(MAX(0.,THETASD-10.)+MIN(THETASD,10.)/0.1)+1
C     Don't run off ends of table
      N1S=MIN(100,MAX0(1,N1S-1))
c      CALL LAGRN(THETA(N1S),P(N1S),THETAS,PS1)
C      WRITE(6,FMT='(F12.5)')THETA
C	  WRITE(6,FMT='(F12.5)') P
	  CALL LAGRN2(THETA,P,271,THETAS,PS1)
C	  WRITE(6,*) THETAS,PSI
      
C     Form the full Hapke S function at this point.
      GAMMA=SQRT(1.0-W)
      HMUO=(1.0+2.*XMUO)/(1.0+2.*GAMMA*XMUO)
      HMU=(1.0+2.*XMU)/(1.0+2.*GAMMA*XMU)
      PS=(XMU*XMUO)/(XMU+XMUO)*W*(PS1+HMUO*HMU-1.0)

C     Integrate the first coefficient
      S(1)=S(1)+PS*WT
C     Integrate all other necessary coefficients
      DO 20 M=2,MAXM
20    S(M)=S(M)+PS*XCOS(I,M-1)*WT

      DO 30 M=1,MAXM
30    S(M)=S(M)*DPHI/3.*2./PI
      S(1)=S(1)/2.
C      write(6,'("XMU = ",1pg11.3," XMUO = ",1pg11.3,"  Coefs: ",
C     &  (1p8g11.3))') XMU,XMUO,(S(M),M=1,64)
      RETURN
      END
      SUBROUTINE AGG2(LAYER,WAVL,AMU1,AMU2,STRUCFN,TAUAGGS,WAGGS,PAGG)
C  This subroutine computes the scattering properties of the fractal
C  aggregate particles.  The size distribution of these particles is
C  contained in the file whose name is stored in variable AGG_FN.  This
C  is an Erich Karkoschka-style file (presently produced by fall.f and
C  named fall.out).
      PARAMETER (NUMCOEFS=256,NUMDPTS=160,NUMG=64,NUMLAYERS=32)
      CHARACTER LINE*255,STRUCFN*255,SIZFN*255
      DIMENSION BINRAD(15),POP(47),PHASEBIN(271),PHASE(271),
     & P(271),THETAD(271),THETA(271),SS(271),RMON(47),PHASESUM(271)
      REAL M11(271),M21(271),M22(271),M33(271),M11SUM(271),M21SUM(271),
     & M22SUM(271),M33SUM(271),LENGTH
      DIMENSION N(47),ALTTOP(47),ALTBOT(47)
      DIMENSION PAGG(271),QAGG(271),UAGG(271),VAGG(271)
      DIMENSION XLINE(10)
      COMMON/SIZD/SIZFN,LAYER1(NUMLAYERS),LAYER2(NUMLAYERS)
      DATA IAGG_FLAG/0/
      
      PI=3.14159265358979
      DEG2RAD=PI/180.0
      
C     GENERATE THE SCATTERING ANGLES
      DO 100 I=1,271
      THETAD(I)=(MIN(I-1,100)*0.1 + MAX(I-101,0)*1.0)
100   THETA(I)=THETAD(I)*DEG2RAD

      
C  Open the size distribution file and read it
      IF(IAGG_FLAG.EQ.0) THEN
        OPEN(15,IOSTAT=IOS,FILE=STRUCFN,STATUS='OLD')
        IF(IOS.NE.0) THEN
          WRITE(6,1000) STRUCFN
1000      FORMAT('Error opening file ',A)
          STOP
        ENDIF
      
        READ(15,1004) LINE
        READ(15,1004) LINE
1004    FORMAT(A)
       
C  Each bin in fall.out represents a particle with 2**(N+1) monomers
C10      DO I=1,15
C          N(I)=2.0**I
C        ENDDO
C        
C        READ(15,1002) BINRAD
C1002    FORMAT(3X,15F5.0)
C        DO I=1,15
C          BINRAD(I)=RMONOMER*N(I)**(1.0/3.0)
C        ENDDO
C
C        DO L=1,46
C          READ(15,1003) (POP(J,L),J=1,15)
C1003      FORMAT(4X,F3.0,14F5.0)
C        ENDDO

         DO L=1,47
	   READ(15,*) XLINE
	   ALTTOP(L)=XLINE(2)
	   ALTBOT(L)=XLINE(3)
	   POP(L)=XLINE(8)
	   RMON(L)=XLINE(9)
	   N(L)=XLINE(10)
C1003       FORMAT(3X,2E10.0,43X,E11.0,F8.0,I6)
         ENDDO
      
        CLOSE(15)
        IAGG_FLAG=1
      ENDIF
      
C  LAYER1(I) AND LAYER2(I) CONTAIN THE TOP AND BOTTOM CLOUD PHYSICS
C  LAYER NUMBERS COMPRISING INTSCLD LAYER I.  SUM THE SCATTERING
C  AND ABSORPTION OPTICAL DEPTH IN EACH CLOUD PHYSICS LAYER BETWEEN
C  LAYER 1 AND LAYER 2 TO GET THE OPTICALS DEPTHS IN LAYER I.
C  THIS SECTION USES MARTY TOMASKO'S PARAMETRIC FITS TO MARK LEMMON'S
C  AGGREGATE SCATTERING CALCULATIONS.  SEE THE DOCUMENT "NOTES FOR
C  FITTING SCATTERING PARAMETERS TO DISCRETE DIPOLE CALCULATIONS FOR
C  FRACTAL AGGREGATE PARTICLES"

      TAUSCA=0.0
      TAUABS=0.0
      DO I=1,271
        PHASESUM(I)=0.0
      ENDDO

      TAUSCA=0.0
      TAUABS=0.0

      DO L=LAYER1(LAYER),LAYER2(LAYER)
	LENGTH=ALTTOP(L)-ALTBOT(L)
        DO I=1,271
          M11SUM(I)=0.0
          M21SUM(I)=0.0
          M22SUM(I)=0.0
          M33SUM(I)=0.0
        ENDDO
        XM=2.0*PI*RMON(L)/WAVL
   	CALL AGG_MAKE_271(N(L),XM,AMU1,AMU2,QSCA,QABS,M11,M21,M22,M33)
        SIGMASCA=QSCA*PI*RMON(L)**2*N(L)**(2./3.)
        SIGMAABS=QABS*PI*RMON(L)**2*N(L)**(2./3.)
        TAUSCALAY=SIGMASCA*POP(L)*LENGTH*1.0E-8
        DO J=1,271
          M11SUM(J)=M11SUM(J)+TAUSCALAY*M11(J)
          M21SUM(J)=M21SUM(J)+TAUSCALAY*M21(J)
          M22SUM(J)=M22SUM(J)+TAUSCALAY*M22(J)
          M33SUM(J)=M33SUM(J)+TAUSCALAY*M33(J)
        ENDDO
        TAUABSLAY=SIGMAABS*POP(L)*LENGTH*1.0E-8
        TAUSCA=TAUSCA+TAUSCALAY
        TAUABS=TAUABS+TAUABSLAY
      ENDDO
      
C  COMPUTE THE EXTINCTION OPTICAL DEPTH AND THE SINGLE SCATTERING
C  ALBEDO FOR THIS INTSCLD LAYER
      TAUAGGS=TAUSCA+TAUABS
      IF(TAUAGGS.GT.0.0) THEN
        WAGGS=TAUSCA/TAUAGGS
      ELSE
        WAGGS=0.0
      ENDIF
      
C     NORMALIZE THE PHASE FUNCTION, STARTING BY INTEGRATING IT OVER
C     SCATTERING ANGLE USING SIMPSON'S RULE
      IF(TAUSCA.GT.0.0) THEN
        SUM1=0.0
        DO J=2,100
	  IF(J.EQ.J/2*2) THEN
	    WEIGHT=4.0
	  ELSE
	    WEIGHT=2.0
	  ENDIF
          SUM1=SUM1+WEIGHT*M11SUM(J)*SIN(THETA(J))
        ENDDO

        SUM1=SUM1+1.0*M11SUM(101)*SIN(THETA(101))

        SUM1=SUM1*0.1*(PI/180.0)/3.0

        SUM2=1.0*M11SUM(101)*SIN(THETA(101))
        DO J=102,270
          IF(J .EQ. J/2*2) THEN
            WEIGHT=4.0
          ELSE
            WEIGHT=2.0
          ENDIF
          SUM2=SUM2+WEIGHT*M11SUM(J)*SIN(THETA(J))
        ENDDO

        SUM2=SUM2*(PI/180.0)/3.0

        SUM=SUM1+SUM2
     
        DO J=1,271
          PAGG(J)=M11SUM(J)*2.0/SUM
C	  QAGG(J)=M21SUM(J)*2.0/SUM
C	  UAGG(J)=M22SUM(J)*2.0/SUM
C	  VAGG(J)=M33SUM(J)*2.0/SUM
        ENDDO

        STUPID=1.0
      ELSE
        DO J=1,271
          PAGG(J)=0.0
C	  QAGG(J)=0.0
C	  UAGG(J)=0.0
C	  VAGG(J)=0.0
        ENDDO
      ENDIF
      
      RETURN
      END
      SUBROUTINE NORMALIZE(P,PNORM)
C     RETURN A NORMALIZED VERSION OF THE INPUT PHASE FUNCTION
      DIMENSION P(271),PNORM(271),THETAD(271),THETA(271)
      PI=3.14159265358979D0
      DEG2RAD=PI/180.0D0
      
C     GENERATE THE SCATTERING ANGLES
      DO 100 I=1,271
      THETAD(I)=MIN(I-1,100)*0.1 + MAX(I-101,0)*1.0
      THETA(I)=THETAD(I)*DEG2RAD
100   CONTINUE
      
C     NORMALIZE THE PHASE FUNCTION BY INTEGRATING IT OVER
C     SCATTERING ANGLE USING A TWO-PIECE TRAPEZOIDAL RULE
      SUM=0.5D0*P(101)*SIN(THETA(101))
      DO J=2,100
        SUM=SUM+P(J)*SIN(THETA(J))
      ENDDO
      SUM1=0.1D0*DEG2RAD*SUM
      SUM=0.5D0*P(101)*SIN(THETA(101))
      DO J=102,270
        SUM=SUM+P(J)*SIN(THETA(J))
      ENDDO
      SUM2=DEG2RAD*SUM
      SUM=SUM1+SUM2
      
      DO J=1,271
        PNORM(J)=2.0D0*P(J)/SUM
      ENDDO
      
      RETURN
      END

